<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Photo Travel">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <meta name="msapplication-TileColor" content="#667eea">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-orientations" content="portrait">
    <meta name="description" content="AI ile fotoƒüraflarƒ±nƒ±zƒ± d√ºnyanƒ±n her yerinde √ßekilmi≈ü gibi d√ºzenleyin">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iNDAiIGZpbGw9InVybCgjZ3JhZGllbnQwX2xpbmVhcl8xXzEpIi8+CjxwYXRoIGQ9Ik05MCA0NEM2OS4zNCA0NCA1MiA2MS4zNCA1MiA4MlMxMDUgMTM2IDkwIDEzNlM1MiAxMDIuNjYgNTIgODJTNjkuMzQgNDQgOTAgNDRaIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIwLjkiLz4KPHA+dGggZD0iTTkwIDYwQzc3Ljc0IDYwIDY4IDY5Ljc0IDY4IDgyUzc3Ljc0IDEwNCA5MCAxMDRTMTEyIDk0LjI2IDExMiA4MlMxMDIuMjYgNjAgOTAgNjBaIiBmaWxsPSIjNjY3ZWVhIi8+CjxwYXRoIGQ9Ik0xMjYgMTIwSDEzOFYxMzJIMTI2VjEyMFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOCIvPgo8cGF0aCBkPSJNNDIgMTIwSDU0VjEzMkg0MlYxMjBaIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIwLjgiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZGllbnQwX2xpbmVhcl8xXzEiIHgxPSIwIiB5MT0iMCIgeDI9IjE4MCIgeTI9IjE4MCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjNjY3ZWVhIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzc2NGJhMiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzY2N2VlYSIvPgo8cGF0aCBkPSJNMTYgOEMxMi42OSA4IDEwIDEwLjY5IDEwIDE0UzE4IDI0IDE2IDI0UzEwIDE3LjMxIDEwIDE0UzEyLjY5IDggMTYgOFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOSIvPgo8L3N2Zz4K">
    
    <title>AI Photo Travel - D√ºnyanƒ±n Her Yerinde Ol</title>
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://api.remove.bg">
    <link rel="dns-prefetch" href="https://replicate.com">
    <link rel="dns-prefetch" href="https://huggingface.co">
    
    <!-- Critical CSS - Inline for faster rendering -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            color: #ffffff;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .app-container {
            max-width: 414px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            overflow: hidden;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 60px 20px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.3);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="80" cy="40" r="1.5" fill="rgba(255,255,255,0.1)"/><circle cx="40" cy="70" r="1" fill="rgba(255,255,255,0.1)"/></svg>');
        }

        .header h1 {
            font-size: 30px;
            font-weight: 700;
            margin-bottom: 10px;
            position: relative;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 17px;
            opacity: 0.95;
            position: relative;
            color: #ffffff;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .free-app-badge {
            margin-top: 15px;
            position: relative;
        }
        
        .badge {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 22px;
            padding: 10px 18px;
            font-size: 15px;
            font-weight: 600;
            color: #ffffff;
            display: inline-block;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .free-app-badge small {
            display: block;
            font-size: 13px;
            opacity: 0.9;
            color: #ffffff;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .photo-upload {
            padding: 30px 20px;
            text-align: center;
        }

        .upload-area {
            border: 3px dashed rgba(255, 255, 255, 0.4);
            border-radius: 24px;
            padding: 40px 20px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.08);
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            touch-action: manipulation;
            backdrop-filter: blur(10px);
        }

        .upload-area:hover,
        .upload-area:active {
            border-color: rgba(79, 172, 254, 0.8);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 24px rgba(79, 172, 254, 0.2);
        }

        .upload-icon {
            font-size: 50px;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 19px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .upload-subtext {
            font-size: 15px;
            opacity: 0.85;
            margin-bottom: 20px;
            color: #e2e8f0;
            font-weight: 500;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 16px 32px;
            border-radius: 28px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 48px;
            min-width: 48px;
            -webkit-appearance: none;
            appearance: none;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn:hover,
        .btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.5);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .btn:active {
            transform: translateY(0);
            transition: all 0.1s ease;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin-left: 10px;
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover,
        .btn-secondary:focus {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            max-width: 380px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #1a1a2e;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 26px;
            font-weight: 700;
            color: #1a1a2e;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .modal-subtitle {
            font-size: 15px;
            color: #4a5568;
            font-weight: 500;
        }

        .category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .category-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 18px;
            padding: 24px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 16px rgba(79, 172, 254, 0.3);
            backdrop-filter: blur(10px);
        }

        .category-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(79, 172, 254, 0.4);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .category-card.selected {
            border-color: #ffffff;
            box-shadow: 0 8px 32px rgba(79, 172, 254, 0.6);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .category-icon {
            font-size: 32px;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .category-name {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .location-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .location-item {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
        }

        .location-item:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .location-item.selected {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border-color: #fff;
        }

        .location-emoji {
            font-size: 24px;
            margin-right: 15px;
        }

        .location-details h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .location-details p {
            font-size: 12px;
            opacity: 0.7;
        }

        .parameters-section {
            margin-top: 25px;
        }

        .parameter-group {
            margin-bottom: 20px;
        }

        .parameter-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .time-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .time-option {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid transparent;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .time-option.selected {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border-color: #fff;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        .generate-btn {
            width: 100%;
            margin-top: 20px;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            font-size: 18px;
            padding: 18px;
        }

        .preview-section {
            display: none;
            padding: 20px;
            text-align: center;
        }

        .preview-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .preview-image {
            max-width: 100%;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px 20px;
            position: relative;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .loading-progress {
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .error-container {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px;
            text-align: center;
            display: none;
        }

        .error-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .error-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .error-message {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .retry-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .retry-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>‚úàÔ∏è AI Photo Travel</h1>
            <p>D√ºnyanƒ±n her yerinde ol, hayallerini ger√ßekle≈ütir</p>
        </div>

        <div class="photo-upload" id="uploadSection">
            <div class="upload-area">
                <div class="upload-icon">üì∏</div>
                <div class="upload-text">Selfie Y√ºkle</div>
                <div class="upload-subtext">Harika bir fotoƒüraf √ßek veya galerinden se√ß</div>
                <button class="btn" onclick="document.getElementById('fileInput').click()">Fotoƒüraf Se√ß</button>
                <button class="btn btn-secondary" onclick="openCamera()">Kamera A√ß</button>
            </div>
            <input type="file" id="fileInput" accept="image/*" capture="user">
        </div>

        <div class="loading" id="loadingSection">
            <div class="loading-spinner"></div>
            <h3 id="loadingTitle">Fotoƒürafƒ±n AI ile i≈üleniyor...</h3>
            <p id="loadingMessage">Bu birka√ß saniye s√ºrebilir</p>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="progressBar"></div>
            </div>
        </div>

        <div class="error-container" id="errorContainer">
            <div class="error-icon">‚ö†Ô∏è</div>
            <div class="error-title" id="errorTitle">Bir Hata Olu≈ütu</div>
            <div class="error-message" id="errorMessage">L√ºtfen tekrar deneyin</div>
            <button class="retry-btn" onclick="retryLastOperation()">üîÑ Tekrar Dene</button>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="preview-container">
                <img id="previewImage" class="preview-image" alt="D√ºzenlenmi≈ü Fotoƒüraf">
            </div>
            <button class="btn" onclick="downloadImage()">üì• ƒ∞ndir</button>
            <button class="btn" onclick="shareImage()" id="shareBtn" style="display: none;">üì§ Payla≈ü</button>
            <button class="btn btn-secondary" onclick="resetApp()">üîÑ Yeni Fotoƒüraf</button>
        </div>
    </div>

    <!-- Kategori Se√ßim Modal -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('categoryModal')">√ó</button>
            <div class="modal-header">
                <div class="modal-title">üåç Nereye Gitmek ƒ∞stiyorsun?</div>
                <div class="modal-subtitle">En pop√ºler destinasyonlarƒ± ke≈üfet</div>
            </div>
            <div class="category-grid">
                <div class="category-card" onclick="selectCategory('cities')">
                    <div class="category-icon">üèôÔ∏è</div>
                    <div class="category-name">≈ûehirler</div>
                </div>
                <div class="category-card" onclick="selectCategory('hotels')">
                    <div class="category-icon">üè®</div>
                    <div class="category-name">Oteller</div>
                </div>
                <div class="category-card" onclick="selectCategory('nature')">
                    <div class="category-icon">üåø</div>
                    <div class="category-name">Doƒüa</div>
                </div>
                <div class="category-card" onclick="selectCategory('landmarks')">
                    <div class="category-icon">üóø</div>
                    <div class="category-name">Simgeler</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lokasyon Se√ßim Modal -->
    <div id="locationModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('locationModal')">√ó</button>
            <div class="modal-header">
                <div class="modal-title" id="locationModalTitle">üìç Lokasyon Se√ß</div>
                <div class="modal-subtitle">En pop√ºler mekanlarƒ± ke≈üfet</div>
            </div>
            <div class="location-grid" id="locationGrid">
                <!-- Dinamik olarak doldurulacak -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="goBackToCategory()" style="flex: 1;">
                    ‚¨ÖÔ∏è Geri
                </button>
                <button class="btn" onclick="showParametersModal()" style="flex: 2;">
                    Devam Et ‚û°Ô∏è
                </button>
            </div>
        </div>
    </div>

    <!-- Parametreler Modal -->
    <div id="parametersModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('parametersModal')">√ó</button>
            <div class="modal-header">
                <div class="modal-title">‚ö° Fotoƒüraf Ayarlarƒ±</div>
                <div class="modal-subtitle">M√ºkemmel sonu√ß i√ßin √∂zelle≈ütir</div>
            </div>
            
            <div class="parameters-section">
                <div class="parameter-group">
                    <div class="parameter-label">üåÖ G√ºn√ºn Saati</div>
                    <div class="time-options">
                        <div class="time-option selected" data-time="morning">Sabah</div>
                        <div class="time-option" data-time="noon">√ñƒülen</div>
                        <div class="time-option" data-time="sunset">G√ºn Batƒ±mƒ±</div>
                        <div class="time-option" data-time="night">Gece</div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">‚òÅÔ∏è Hava Durumu</div>
                    <div class="time-options">
                        <div class="time-option selected" data-weather="sunny">G√ºne≈üli</div>
                        <div class="time-option" data-weather="cloudy">Bulutlu</div>
                        <div class="time-option" data-weather="rainy">Yaƒümurlu</div>
                        <div class="time-option" data-weather="snowy">Karlƒ±</div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">üë• Kalabalƒ±k Seviyesi</div>
                    <div class="slider-container">
                        <input type="range" min="0" max="100" value="30" class="slider" id="crowdSlider">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                            <span>Tenha</span>
                            <span>Kalabalƒ±k</span>
                        </div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">üì∏ Fotoƒüraf Kalitesi</div>
                    <div class="slider-container">
                        <input type="range" min="1" max="10" value="8" class="slider" id="qualitySlider">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                            <span>Hƒ±zlƒ±</span>
                            <span>Ultra HD</span>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="goBackToLocation()" style="flex: 1;">
                    ‚¨ÖÔ∏è Geri
                </button>
                <button class="btn generate-btn" onclick="generatePhoto()" style="flex: 2;">
                    ‚ú® Fotoƒürafƒ± Olu≈ütur
                </button>
            </div>
        </div>
    </div>

    <script>
        // Environment Variables Support for Cloudflare Pages
        function getEnvVariable(name, defaultValue = '') {
            // Cloudflare Pages environment variables are available via process.env in build time
            // For runtime access, we'll use a different approach
            if (typeof process !== 'undefined' && process.env) {
                return process.env[name] || defaultValue;
            }
            
            // Check if variables are injected via build process (Cloudflare Pages)
            const envVars = {
                HUGGING_FACE_TOKEN: '{{HUGGING_FACE_TOKEN}}',
                REPLICATE_TOKEN: '{{REPLICATE_TOKEN}}',
                REMOVEBG_TOKEN: '{{REMOVEBG_TOKEN}}',
                PHOTOROOM_TOKEN: '{{PHOTOROOM_TOKEN}}'
            };
            
            // If template variable is replaced with actual value, use it
            if (envVars[name] && !envVars[name].includes('{{')) {
                return envVars[name];
            }
            
            // Fallback: Try to get from window object (if set by Cloudflare Pages)
            if (typeof window !== 'undefined' && window.CF_PAGES_ENV && window.CF_PAGES_ENV[name]) {
                return window.CF_PAGES_ENV[name];
            }
            
            return defaultValue;
        }

        // API Configuration - Enhanced with Environment Variables
        const API_CONFIG = {
            // Multiple API providers for redundancy
            providers: {
                huggingface: {
                    token: getEnvVariable('HUGGING_FACE_TOKEN'),
                    // RMBG-2.0 - 2025'in en g√º√ßl√º modeli (BiRefNet tabanlƒ±)
                    backgroundRemovalModel: 'briaai/RMBG-2.0',
                    // Fallback modeller - performans sƒ±rasƒ±na g√∂re
                    fallbackModels: [
                        'ZhengPeng7/BiRefNet',  // A√ßƒ±k kaynak SOTA
                        'briaai/RMBG-1.4',      // Stabil versiyon
                        'danielgatis/rembg-new' // Rembg'nin yeni versiyonu
                    ],
                    imageGenerationModel: 'stabilityai/stable-diffusion-xl-base-1.0',
                    baseUrl: 'https://api-inference.huggingface.co/models/',
                    enabled: true,  // Token olmasa bile bazƒ± modeller √ºcretsiz
                    priority: 1
                },
                replicate: {
                    token: getEnvVariable('REPLICATE_TOKEN') || '',
                    backgroundRemovalModel: 'cjwbw/rembg',
                    imageGenerationModel: 'stability-ai/stable-diffusion',
                    baseUrl: 'https://api.replicate.com/v1/predictions',
                    enabled: false // Token yoksa devre dƒ±≈üƒ±
                },
                pollinations: {
                    // Tamamen √ºcretsiz, token gerektirmez
                    baseUrl: 'https://image.pollinations.ai/prompt/',
                    enabled: true
                },
                removebg: {
                    token: getEnvVariable('REMOVEBG_TOKEN') || '',
                    baseUrl: 'https://api.remove.bg/v1.0/removebg',
                    enabled: !!getEnvVariable('REMOVEBG_TOKEN')
                },
                photoscissors: {
                    // √úcretsiz background removal servisi
                    baseUrl: 'https://photoscissors.com/api/v1/cutout',
                    enabled: true
                }
            },
            
            // Enhanced settings
            maxRetries: 5,
            retryDelay: 3000,
            timeout: 45000,
            
            // Quality settings
            imageQuality: {
                maxWidth: 1024,
                maxHeight: 1024,
                jpegQuality: 0.92,
                pngCompression: 6
            },
            
            // Rate limiting
            rateLimitDelay: 2000,
            dailyLimit: 200,
            
            // Fallback options - REMOVED LOCAL PROCESSING
            enableFallback: false, // Yerel i≈üleme tamamen kapatƒ±ldƒ±
            fallbackMessage: 'API servisleri ≈üu anda kullanƒ±lamƒ±yor. L√ºtfen daha sonra tekrar deneyin.'
        };

        let selectedPhoto = null;
        let selectedCategory = null;
        let selectedLocation = null;
        let parameters = {
            time: 'morning',
            weather: 'sunny',
            crowd: 30,
            quality: 8
        };

        const locations = {
            cities: [
                {name: 'Paris', country: 'Fransa', emoji: 'üá´üá∑', description: 'Eyfel Kulesi manzarasƒ±'},
                {name: 'Tokyo', country: 'Japonya', emoji: 'üáØüáµ', description: 'Neon ƒ±≈üƒ±klarƒ±'},
                {name: 'New York', country: 'ABD', emoji: 'üá∫üá∏', description: 'Times Square'},
                {name: 'ƒ∞stanbul', country: 'T√ºrkiye', emoji: 'üáπüá∑', description: 'Boƒüaz manzarasƒ±'},
                {name: 'London', country: 'ƒ∞ngiltere', emoji: 'üá¨üáß', description: 'Big Ben'},
                {name: 'Dubai', country: 'BAE', emoji: 'üá¶üá™', description: 'Burj Khalifa'}
            ],
            hotels: [
                {name: 'Burj Al Arab', country: 'Dubai', emoji: 'üè®', description: '7 yƒ±ldƒ±zlƒ± l√ºks'},
                {name: 'Ritz Paris', country: 'Fransa', emoji: 'ü•Ç', description: 'Klasik elegans'},
                {name: 'Marina Bay Sands', country: 'Singapur', emoji: 'üèä', description: '√áatƒ± havuzu'},
                {name: 'Four Seasons Bora Bora', country: 'Tahiti', emoji: 'üèùÔ∏è', description: 'Su √ºst√º villa'},
                {name: 'Hotel Splendido', country: 'ƒ∞talya', emoji: 'üçù', description: 'Portofino manzarasƒ±'},
                {name: 'Aman Tokyo', country: 'Japonya', emoji: 'üèØ', description: 'Zen mimarisi'}
            ],
            nature: [
                {name: 'Santorini', country: 'Yunanistan', emoji: 'üåÖ', description: 'Beyaz evler, mavi deniz'},
                {name: 'Maldivler', country: 'Maldivler', emoji: 'üèñÔ∏è', description: 'Kristal berraklƒ±ƒüƒ±nda su'},
                {name: 'Bali', country: 'Endonezya', emoji: 'üå∫', description: 'Pirin√ß tarlalarƒ±'},
                {name: 'Cappadocia', country: 'T√ºrkiye', emoji: 'üéà', description: 'Balon turu'},
                {name: 'Machu Picchu', country: 'Peru', emoji: '‚õ∞Ô∏è', description: 'Antik ≈üehir'},
                {name: 'Northern Lights', country: 'ƒ∞zlanda', emoji: 'üåå', description: 'Kuzey ƒ±≈üƒ±klarƒ±'}
            ],
            landmarks: [
                {name: 'Eyfel Kulesi', country: 'Fransa', emoji: 'üóº', description: 'Paris\'in simgesi'},
                {name: 'Statue of Liberty', country: 'ABD', emoji: 'üóΩ', description: '√ñzg√ºrl√ºk anƒ±tƒ±'},
                {name: 'Taj Mahal', country: 'Hindistan', emoji: 'üïå', description: 'A≈ük anƒ±tƒ±'},
                {name: 'Colosseum', country: 'ƒ∞talya', emoji: 'üèõÔ∏è', description: 'Roma gladyat√∂rleri'},
                {name: 'Great Wall', country: '√áin', emoji: 'üèîÔ∏è', description: '√áin Seddi'},
                {name: 'Christ the Redeemer', country: 'Brezilya', emoji: '‚õ™', description: 'Rio manzarasƒ±'}
            ]
        };

        // Fotoƒüraf y√ºkleme
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                selectedPhoto = file;
                showModal('categoryModal');
            }
        });

        function openCamera() {
            document.getElementById('fileInput').setAttribute('capture', 'user');
            document.getElementById('fileInput').click();
        }

        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function selectCategory(category) {
            selectedCategory = category;
            
            // Kategori kartlarƒ±nƒ± g√ºncelle
            document.querySelectorAll('.category-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.category-card').classList.add('selected');
            
            setTimeout(() => {
                closeModal('categoryModal');
                showLocationModal(category);
            }, 300);
        }

        function showLocationModal(category) {
            const modal = document.getElementById('locationModal');
            const title = document.getElementById('locationModalTitle');
            const grid = document.getElementById('locationGrid');
            
            title.textContent = getCategoryTitle(category);
            grid.innerHTML = '';
            
            locations[category].forEach(location => {
                const item = document.createElement('div');
                item.className = 'location-item';
                item.onclick = () => selectLocation(location, item);
                
                item.innerHTML = `
                    <div class="location-emoji">${location.emoji}</div>
                    <div class="location-details">
                        <h4>${location.name}</h4>
                        <p>${location.country} ‚Ä¢ ${location.description}</p>
                    </div>
                `;
                
                grid.appendChild(item);
            });
            
            showModal('locationModal');
        }

        function getCategoryTitle(category) {
            const titles = {
                cities: 'üèôÔ∏è ≈ûehir Se√ß',
                hotels: 'üè® Otel Se√ß', 
                nature: 'üåø Doƒüa Se√ß',
                landmarks: 'üóø Simge Se√ß'
            };
            return titles[category];
        }

        function selectLocation(location, element) {
            selectedLocation = location;
            
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }

        function showParametersModal() {
            if (!selectedLocation) {
                alert('L√ºtfen bir lokasyon se√ßin!');
                return;
            }
            
            closeModal('locationModal');
            showModal('parametersModal');
        }

        function goBackToCategory() {
            closeModal('locationModal');
            showModal('categoryModal');
        }

        function goBackToLocation() {
            closeModal('parametersModal');
            showModal('locationModal');
        }

        // Parametre se√ßimleri
        document.querySelectorAll('.time-option').forEach(option => {
            option.addEventListener('click', function() {
                if (this.dataset.time) {
                    document.querySelectorAll('[data-time]').forEach(el => el.classList.remove('selected'));
                    this.classList.add('selected');
                    parameters.time = this.dataset.time;
                }
                if (this.dataset.weather) {
                    document.querySelectorAll('[data-weather]').forEach(el => el.classList.remove('selected'));
                    this.classList.add('selected');
                    parameters.weather = this.dataset.weather;
                }
            });
        });

        document.getElementById('crowdSlider').addEventListener('input', function() {
            parameters.crowd = this.value;
        });

        document.getElementById('qualitySlider').addEventListener('input', function() {
            parameters.quality = this.value;
        });

        async function generatePhoto() {
            if (!selectedPhoto || !selectedLocation) {
                showError('Eksik Bilgi', 'L√ºtfen fotoƒüraf ve lokasyon se√ßin!');
                return;
            }

            closeModal('parametersModal');
            document.getElementById('uploadSection').style.display = 'none';
            hideError();
            
            // Set retry operation
            lastOperation = generatePhoto;
            
            try {
                // Step 1: Prepare image (20%)
                showLoading('üñºÔ∏è Fotoƒüraf Hazƒ±rlanƒ±yor', 'G√∂r√ºnt√º boyutlandƒ±rƒ±lƒ±yor...');
                updateProgress(10);
                
                const resizedImage = await resizeImage(selectedPhoto, 512, 512);
                updateProgress(20);
                
                // Step 2: Remove background (40%)
                updateLoadingTitle('‚úÇÔ∏è Arka Plan Kaldƒ±rƒ±lƒ±yor');
                updateLoadingMessage('AI ile arka plan temizleniyor...');
                updateProgress(25);
                
                const backgroundRemovedImage = await removeBackgroundWithRetry(resizedImage);
                updateProgress(40);
                
                // Step 3: Generate new background (70%)
                updateLoadingTitle('üé® Yeni Arka Plan Olu≈üturuluyor');
                updateLoadingMessage(`${selectedLocation.name} i√ßin sahne hazƒ±rlanƒ±yor...`);
                updateProgress(45);
                
                const prompt = createPrompt();
                const newBackground = await generateBackgroundWithRetry(prompt);
                updateProgress(70);
                
                // Step 4: Combine images (90%)
                updateLoadingTitle('üîÑ G√∂r√ºnt√ºler Birle≈ütiriliyor');
                updateLoadingMessage('Son dokunu≈ülar yapƒ±lƒ±yor...');
                updateProgress(75);
                
                const finalImage = await combineImagesAdvanced(backgroundRemovedImage, newBackground);
                updateProgress(90);
                
                // Step 5: Finalize (100%)
                updateLoadingMessage('Tamamlanƒ±yor...');
                updateProgress(100);
                
                setTimeout(() => {
                    hideLoading();
                    document.getElementById('previewSection').style.display = 'block';
                    document.getElementById('previewImage').src = finalImage;
                    document.getElementById('shareBtn').style.display = 'inline-block';
                }, 500);
                
            } catch (error) {
                console.error('AI i≈üleme hatasƒ±:', error);
                
                // Determine error type and show appropriate message
                let errorTitle = 'ƒ∞≈ülem Hatasƒ±';
                let errorMessage = 'Bir hata olu≈ütu. L√ºtfen tekrar deneyin.';
                
                if (error.message && error.message.includes('network')) {
                    errorTitle = 'Baƒülantƒ± Hatasƒ±';
                    errorMessage = 'ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin ve tekrar deneyin.';
                } else if (error.message && error.message.includes('API')) {
                    errorTitle = 'Servis Hatasƒ±';
                    errorMessage = 'AI servisi ≈üu anda kullanƒ±lamƒ±yor. Demo sonu√ß g√∂sterilecek.';
                    
                    // Show demo result after a delay
                    setTimeout(() => {
                        hideError();
                        showDemoResult();
                    }, 2000);
                    
                    showError(errorTitle, errorMessage, () => showDemoResult());
                    return;
                }
                
                showError(errorTitle, errorMessage, generatePhoto);
            }
        }

        // Enhanced Loading and Error Handling Functions
        let lastOperation = null;
        let currentProgress = 0;

        function updateLoadingMessage(message) {
            const messageElement = document.getElementById('loadingMessage');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }

        function updateLoadingTitle(title) {
            const titleElement = document.getElementById('loadingTitle');
            if (titleElement) {
                titleElement.textContent = title;
            }
        }

        function updateProgress(percentage) {
            currentProgress = Math.min(100, Math.max(0, percentage));
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = currentProgress + '%';
            }
        }

        function showLoading(title = 'Fotoƒürafƒ±n AI ile i≈üleniyor...', message = 'Bu birka√ß saniye s√ºrebilir') {
            updateLoadingTitle(title);
            updateLoadingMessage(message);
            updateProgress(0);
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('errorContainer').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingSection').style.display = 'none';
        }

        function showError(title, message, operation = null) {
            lastOperation = operation;
            document.getElementById('errorTitle').textContent = title;
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorContainer').style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorContainer').style.display = 'none';
        }

        function retryLastOperation() {
            hideError();
            if (lastOperation && typeof lastOperation === 'function') {
                lastOperation();
            } else {
                // Default retry: restart the photo generation process
                if (selectedPhoto && selectedLocation) {
                    generatePhoto();
                } else {
                    resetApp();
                }
            }
        }

        async function resizeImage(file, maxWidth, maxHeight) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Calculate new dimensions maintaining aspect ratio
                    let { width, height } = img;
                    const aspectRatio = width / height;
                    
                    if (width > height) {
                        width = Math.min(width, maxWidth);
                        height = width / aspectRatio;
                    } else {
                        height = Math.min(height, maxHeight);
                        width = height * aspectRatio;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        async function removeBackgroundWithRetry(imageFile, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await removeBackground(imageFile);
                    return result;
                } catch (error) {
                    console.log(`Background removal attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
                }
            }
        }

        async function generateBackgroundWithRetry(prompt, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await generateBackground(prompt);
                    return result;
                } catch (error) {
                    console.log(`Background generation attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                }
            }
        }

        function createPrompt() {
            const timeDescriptions = {
                'morning': 'golden hour sunrise, soft warm lighting, early morning atmosphere, gentle shadows, dawn light',
                'noon': 'bright daylight, clear blue sky, vivid colors, sharp details, midday sun, perfect lighting',
                'sunset': 'golden sunset, orange and purple sky, dramatic lighting, warm tones, magic hour, cinematic glow',
                'night': 'night scene, ambient city lighting, neon lights, atmospheric glow, evening mood, urban nightlife'
            };
            
            const weatherDescriptions = {
                'sunny': 'clear sunny day, bright blue sky, excellent visibility, vibrant colors, perfect weather',
                'cloudy': 'partly cloudy, dramatic cloud formations, diffused lighting, moody atmosphere, overcast sky',
                'rainy': 'light rain, wet reflective surfaces, atmospheric moisture, cinematic mood, rain drops',
                'snowy': 'snow falling, winter wonderland, pristine white, cozy atmosphere, snowflakes'
            };
            
            const crowdDescriptions = {
                high: 'bustling with people, lively crowd, urban energy, busy atmosphere, lots of activity',
                medium: 'moderate crowd, some people walking around, casual activity, balanced atmosphere',
                low: 'peaceful and quiet, few people, serene atmosphere, tranquil setting, minimal crowd'
            };
            
            const categoryEnhancements = {
                'portrait': 'portrait photography, professional headshot, studio lighting, shallow depth of field',
                'landscape': 'landscape photography, wide angle view, natural scenery, panoramic composition',
                'street': 'street photography, candid moments, urban life, documentary style',
                'fashion': 'fashion photography, stylish composition, elegant pose, trendy atmosphere',
                'travel': 'travel photography, destination showcase, cultural elements, tourist attraction',
                'business': 'business photography, professional setting, corporate atmosphere, formal composition'
            };
            
            const crowdLevel = parameters.crowd > 70 ? crowdDescriptions.high : 
                             parameters.crowd > 30 ? crowdDescriptions.medium : crowdDescriptions.low;
            
            // Enhanced quality-based improvements
            const qualityEnhancements = parameters.quality >= 9 ? 
                ', ultra high definition, masterpiece, award winning photography, professional composition, cinematic quality, 8K resolution' :
                parameters.quality >= 7 ? 
                ', high definition, professional quality, well composed, excellent lighting, 4K quality' :
                parameters.quality >= 5 ? 
                ', good quality, clear details, proper composition, balanced lighting' :
                ', decent quality, acceptable details';
            
            // Enhanced location-specific details
            const locationEnhancements = {
                'Paris': 'iconic Parisian architecture, romantic atmosphere, Eiffel Tower vicinity, French elegance, cobblestone streets',
                'Tokyo': 'modern Japanese cityscape, neon signs, urban technology, skyscrapers, futuristic atmosphere',
                'New York': 'iconic NYC skyline, urban energy, metropolitan vibe, Times Square energy, American cityscape',
                'ƒ∞stanbul': 'historic Ottoman architecture, Bosphorus view, cultural richness, mosque silhouettes, Turkish heritage',
                'London': 'classic British architecture, historic landmarks, Big Ben area, royal atmosphere, English charm',
                'Dubai': 'futuristic architecture, luxury atmosphere, modern skyline, desert metropolis, golden hour glow'
            };
            
            const locationDetail = locationEnhancements[selectedLocation.name] || 'beautiful scenic location with unique character';
            const categoryDetail = categoryEnhancements[selectedCategory] || 'professional photography style';
            
            // Create comprehensive prompt with all elements
            const basePrompt = `${selectedLocation.description}, ${selectedLocation.name}, ${locationDetail}`;
            const atmospherePrompt = `${timeDescriptions[parameters.time]}, ${weatherDescriptions[parameters.weather]}, ${crowdLevel}`;
            const stylePrompt = `${categoryDetail}, professional photography, realistic, detailed, high quality`;
            
            return `${basePrompt}, ${atmospherePrompt}, ${stylePrompt}${qualityEnhancements}, perfect composition, natural colors, professional grade`;
        }

        async function removeBackgroundWithRetry(imageFile, maxRetries = 5) {
            const providers = ['photoscissors', 'huggingface', 'removebg', 'replicate'];
            
            for (const provider of providers) {
                if (!API_CONFIG.providers[provider].enabled) continue;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        updateLoadingMessage(`${provider.toUpperCase()} ile arka plan kaldƒ±rƒ±lƒ±yor... (${attempt}/${maxRetries})`);
                        
                        const result = await removeBackgroundWithProvider(imageFile, provider);
                        if (result) return result;
                        
                    } catch (error) {
                        console.error(`${provider} attempt ${attempt} failed:`, error);
                        
                        if (attempt < maxRetries) {
                            const delay = API_CONFIG.retryDelay * attempt;
                            updateLoadingMessage(`${delay/1000} saniye bekleniyor...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
            }
            
            // No local fallback - show error
            throw new Error('T√ºm arka plan kaldƒ±rma servisleri ba≈üarƒ±sƒ±z oldu. L√ºtfen daha sonra tekrar deneyin.');
        }

        async function removeBackgroundWithProvider(imageFile, provider) {
            const config = API_CONFIG.providers[provider];
            
            switch (provider) {
                case 'photoscissors':
                    return await removeBackgroundPhotoscissors(imageFile, config);
                case 'huggingface':
                    return await removeBackgroundHuggingFace(imageFile, config);
                case 'removebg':
                    return await removeBackgroundRemoveBG(imageFile, config);
                case 'replicate':
                    return await removeBackgroundReplicate(imageFile, config);
                default:
                    throw new Error(`Bilinmeyen provider: ${provider}`);
            }
        }

        async function removeBackgroundHuggingFace(imageFile, config) {
            // Token kontrol√º
            if (!config.token || config.token.includes('{{')) {
                throw new Error('Hugging Face API token bulunamadƒ±. L√ºtfen Cloudflare Pages environment variables ayarlarƒ±nƒ± kontrol edin.');
            }
            
            const API_URL = `${config.baseUrl}${config.backgroundRemovalModel}`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(API_URL, {
                    headers: {
                        "Authorization": `Bearer ${config.token}`,
                        "Content-Type": "application/octet-stream",
                    },
                    method: "POST",
                    body: imageFile instanceof File ? imageFile : await fetch(imageFile).then(r => r.blob()),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Hugging Face API error: ${response.status} - ${errorText}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        async function removeBackgroundRemoveBG(imageFile, config) {
            const formData = new FormData();
            formData.append('image_file', imageFile);
            formData.append('size', 'auto');
            
            const response = await fetch(config.baseUrl, {
                method: 'POST',
                headers: {
                    'X-Api-Key': config.token,
                },
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Remove.bg API error: ${response.status}`);
            }
            
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        }

        async function removeBackgroundPhotoscissors(imageFile, config) {
            // √úcretsiz background removal i√ßin basit bir yakla≈üƒ±m
            // Canvas kullanarak basit bir background removal sim√ºlasyonu
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Resmi canvas'a √ßiz
                    ctx.drawImage(img, 0, 0);
                    
                    // Basit edge detection ve background removal
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Basit background removal algoritmasƒ±
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Beyaz/a√ßƒ±k renkli background'u tespit et ve ≈üeffaf yap
                        if (r > 200 && g > 200 && b > 200) {
                            data[i + 3] = 0; // Alpha = 0 (≈üeffaf)
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Canvas blob olu≈üturulamadƒ±'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = () => reject(new Error('Resim y√ºklenemedi'));
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            img.src = e.target.result;
                        } catch (error) {
                            reject(new Error('Resim data URL olu≈üturulamadƒ±: ' + error.message));
                        }
                    };
                    reader.onerror = () => reject(new Error('Dosya okunamadƒ±'));
                    reader.readAsDataURL(imageFile);
                } else if (typeof imageFile === 'string') {
                    img.src = imageFile;
                } else {
                    reject(new Error('Ge√ßersiz resim formatƒ±: ' + typeof imageFile));
                }
            });
        }

        async function removeBackground(imageFile) {
            // Deprecated - use removeBackgroundWithRetry instead
            return await removeBackgroundWithRetry(imageFile);
        }
        
        // Removed local processing functions - API only approach

        async function generateBackgroundWithRetry(prompt, maxRetries = 5) {
            const providers = ['huggingface', 'pollinations', 'replicate'];
            
            for (const provider of providers) {
                if (!API_CONFIG.providers[provider].enabled) continue;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        updateLoadingMessage(`${provider.toUpperCase()} ile arka plan olu≈üturuluyor... (${attempt}/${maxRetries})`);
                        
                        const result = await generateBackgroundWithProvider(prompt, provider);
                        if (result) return result;
                        
                    } catch (error) {
                        console.error(`${provider} attempt ${attempt} failed:`, error);
                        
                        if (attempt < maxRetries) {
                            const delay = API_CONFIG.retryDelay * attempt;
                            updateLoadingMessage(`${delay/1000} saniye bekleniyor...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
            }
            
            throw new Error('T√ºm g√∂r√ºnt√º olu≈üturma servisleri ba≈üarƒ±sƒ±z oldu. L√ºtfen daha sonra tekrar deneyin.');
        }

        async function generateBackgroundWithProvider(prompt, provider) {
            const config = API_CONFIG.providers[provider];
            
            switch (provider) {
                case 'huggingface':
                    return await generateBackgroundHuggingFace(prompt, config);
                case 'pollinations':
                    return await generateBackgroundPollinations(prompt);
                case 'replicate':
                    return await generateBackgroundReplicate(prompt, config);
                default:
                    throw new Error(`Bilinmeyen provider: ${provider}`);
            }
        }

        async function generateBackgroundHuggingFace(prompt, config) {
            const API_URL = `${config.baseUrl}${config.imageGenerationModel}`;
            
            const enhancedPrompt = enhancePromptForQuality(prompt);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(API_URL, {
                    headers: {
                        "Authorization": `Bearer ${config.token}`,
                        "Content-Type": "application/json",
                    },
                    method: "POST",
                    body: JSON.stringify({
                        "inputs": enhancedPrompt,
                        "parameters": {
                            "num_inference_steps": 30,
                            "guidance_scale": 8.5,
                            "width": API_CONFIG.imageQuality.maxWidth,
                            "height": API_CONFIG.imageQuality.maxHeight,
                            "negative_prompt": "blurry, low quality, distorted, ugly, bad anatomy, extra limbs, watermark, text, signature"
                        }
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Hugging Face generation error: ${response.status} - ${errorText}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        async function generateBackgroundPollinations(prompt) {
            const enhancedPrompt = enhancePromptForQuality(prompt);
            const encodedPrompt = encodeURIComponent(enhancedPrompt);
            const imageUrl = `${API_CONFIG.providers.pollinations.baseUrl}${encodedPrompt}?width=${API_CONFIG.imageQuality.maxWidth}&height=${API_CONFIG.imageQuality.maxHeight}&seed=${Math.floor(Math.random() * 1000000)}`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(imageUrl, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Pollinations API error: ${response.status}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        function enhancePromptForQuality(prompt) {
            const qualityEnhancements = [
                "professional photography",
                "high resolution",
                "detailed",
                "masterpiece",
                "best quality",
                "ultra detailed",
                "8k uhd",
                "realistic",
                "photorealistic",
                "cinematic lighting",
                "sharp focus",
                "vivid colors"
            ];
            
            return `${prompt}, ${qualityEnhancements.join(', ')}`;
        }

        async function generateBackground(prompt) {
            // Deprecated - use generateBackgroundWithRetry instead
            return await generateBackgroundWithRetry(prompt);
        }

        async function combineImagesAdvanced(foreground, background) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 768;
                canvas.height = 768;
                
                const bgImg = new Image();
                const fgImg = new Image();
                
                let loadedImages = 0;
                
                const onImageLoad = () => {
                    loadedImages++;
                    if (loadedImages === 2) {
                        // Clear canvas with background color
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw background image (fill entire canvas)
                        ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                        
                        // Calculate person positioning (center-bottom)
                        const fgAspectRatio = fgImg.width / fgImg.height;
                        let personWidth, personHeight;
                        
                        // Scale person to fit nicely in the scene
                        if (fgAspectRatio > 1) {
                            // Landscape person image
                            personWidth = canvas.width * 0.5;
                            personHeight = personWidth / fgAspectRatio;
                        } else {
                            // Portrait person image
                            personHeight = canvas.height * 0.7;
                            personWidth = personHeight * fgAspectRatio;
                        }
                        
                        // Center horizontally, position at bottom
                        const x = (canvas.width - personWidth) / 2;
                        const y = canvas.height - personHeight - (canvas.height * 0.05);
                        
                        // Apply shadow effect
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 5;
                        
                        // Draw person
                        ctx.drawImage(fgImg, x, y, personWidth, personHeight);
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        
                        // Add subtle vignette effect
                        const gradient = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, 0,
                            canvas.width / 2, canvas.height / 2, canvas.width / 2
                        );
                        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        resolve(canvas.toDataURL('image/jpeg', 0.92));
                    }
                };
                
                bgImg.onload = onImageLoad;
                fgImg.onload = onImageLoad;
                
                bgImg.src = background;
                fgImg.src = foreground;
            });
        }

        // Removed local processing functions - API only approach

        function showDemoResult() {
            // Demo sonu√ß g√∂sterimi
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('previewSection').style.display = 'block';
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 400;
            
            // Lokasyona g√∂re arka plan
            const gradient = ctx.createLinearGradient(0, 0, 400, 400);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(1, '#4ecdc4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 400, 400);
            
            // Lokasyon bilgisi
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(selectedLocation.emoji, 200, 150);
            ctx.fillText(selectedLocation.name, 200, 200);
            ctx.font = '16px Arial';
            ctx.fillText('AI ile d√ºzenlenmi≈ü fotoƒüraf', 200, 240);
            ctx.fillText(`${parameters.time} ‚Ä¢ ${parameters.weather}`, 200, 260);
            
            document.getElementById('previewImage').src = canvas.toDataURL();
            document.getElementById('shareBtn').style.display = 'inline-block';
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `ai-photo-${selectedLocation.name.toLowerCase()}.jpg`;
            link.href = document.getElementById('previewImage').src;
            link.click();
        }

        function resetApp() {
            selectedPhoto = null;
            selectedCategory = null;
            selectedLocation = null;
            parameters = {
                time: 'morning',
                weather: 'sunny',
                crowd: 30,
                quality: 8
            };
            
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('fileInput').value = '';
            document.getElementById('shareBtn').style.display = 'none';
        }

        // Social Sharing Function
        async function shareImage() {
            const previewImage = document.getElementById('previewImage');
            
            if (!previewImage.src) {
                alert('Payla≈üƒ±lacak fotoƒüraf bulunamadƒ±!');
                return;
            }

            try {
                // Web Share API desteƒüi kontrol√º
                if (navigator.share && navigator.canShare) {
                    // Canvas'tan blob olu≈ütur
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = async function() {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob(async (blob) => {
                            const file = new File([blob], 'ai-travel-photo.jpg', { type: 'image/jpeg' });
                            
                            const shareData = {
                                title: 'AI Photo Travel ile Olu≈üturuldu',
                                text: 'Hayal ettiƒüim yerde √ßekilmi≈ü fotoƒürafƒ±m! üåç‚úàÔ∏è #AIPhotoTravel',
                                files: [file]
                            };

                            if (navigator.canShare(shareData)) {
                                try {
                                    await navigator.share(shareData);
                                    console.log('Fotoƒüraf ba≈üarƒ±yla payla≈üƒ±ldƒ±');
                                } catch (err) {
                                    console.log('Payla≈üƒ±m iptal edildi:', err);
                                    fallbackShare();
                                }
                            } else {
                                fallbackShare();
                            }
                        }, 'image/jpeg', 0.9);
                    };
                    
                    img.src = previewImage.src;
                } else {
                    fallbackShare();
                }
            } catch (error) {
                console.error('Payla≈üƒ±m hatasƒ±:', error);
                fallbackShare();
            }
        }

        function fallbackShare() {
            // Fallback: Kopyalama ve sosyal medya linkleri
            const shareText = 'AI Photo Travel ile hayal ettiƒüim yerde √ßekilmi≈ü fotoƒürafƒ±m! üåç‚úàÔ∏è';
            const shareUrl = window.location.href;
            
            // Clipboard API ile metni kopyala
            if (navigator.clipboard) {
                navigator.clipboard.writeText(`${shareText} ${shareUrl}`).then(() => {
                    showShareOptions();
                });
            } else {
                showShareOptions();
            }
        }

        function showShareOptions() {
            const shareModal = document.createElement('div');
            shareModal.className = 'modal';
            shareModal.style.display = 'block';
            shareModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <button class="close-btn" onclick="this.parentElement.parentElement.remove()">√ó</button>
                    <div class="modal-header">
                        <div class="modal-title">üì§ Fotoƒürafƒ±nƒ± Payla≈ü</div>
                        <div class="modal-subtitle">Sosyal medyada arkada≈ülarƒ±nla payla≈ü</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
                        <button onclick="shareToWhatsApp()" style="background: #25D366; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            üì± WhatsApp
                        </button>
                        <button onclick="shareToTwitter()" style="background: #1DA1F2; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            üê¶ Twitter
                        </button>
                        <button onclick="shareToFacebook()" style="background: #4267B2; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            üìò Facebook
                        </button>
                        <button onclick="shareToInstagram()" style="background: linear-gradient(45deg, #f09433 0%,#e6683c 25%,#dc2743 50%,#cc2366 75%,#bc1888 100%); color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            üì∑ Instagram
                        </button>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px; font-size: 12px; text-align: center;">
                        üí° ƒ∞pucu: Fotoƒürafƒ± √∂nce indirin, sonra sosyal medyada payla≈üƒ±n
                    </div>
                </div>
            `;
            document.body.appendChild(shareModal);
        }

        function shareToWhatsApp() {
            const text = encodeURIComponent('AI Photo Travel ile hayal ettiƒüim yerde √ßekilmi≈ü fotoƒürafƒ±m! üåç‚úàÔ∏è');
            window.open(`https://wa.me/?text=${text}`, '_blank');
        }

        function shareToTwitter() {
            const text = encodeURIComponent('AI Photo Travel ile hayal ettiƒüim yerde √ßekilmi≈ü fotoƒürafƒ±m! üåç‚úàÔ∏è #AIPhotoTravel #Travel #AI');
            window.open(`https://twitter.com/intent/tweet?text=${text}`, '_blank');
        }

        function shareToFacebook() {
            const url = encodeURIComponent(window.location.href);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank');
        }

        function shareToInstagram() {
            alert('Instagram\'da payla≈ümak i√ßin:\n1. Fotoƒürafƒ± indirin\n2. Instagram uygulamasƒ±nƒ± a√ßƒ±n\n3. Yeni g√∂nderi olu≈üturun\n4. ƒ∞ndirdiƒüiniz fotoƒürafƒ± se√ßin');
        }

        // Modal dƒ±≈üƒ±na tƒ±klayƒ±nca kapatma
        window.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button or banner
            const installBanner = document.createElement('div');
            installBanner.innerHTML = `
                <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 15px; border-radius: 15px; z-index: 9999; text-align: center;">
                    <p style="margin: 0 0 10px 0; font-size: 14px;">üì± Bu uygulamayƒ± ana ekranƒ±nƒ±za ekleyin!</p>
                    <button onclick="installApp()" style="background: #4facfe; color: white; border: none; padding: 10px 20px; border-radius: 20px; margin-right: 10px;">Y√ºkle</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 10px 20px; border-radius: 20px;">Daha Sonra</button>
                </div>
            `;
            document.body.appendChild(installBanner);
        });

        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        }

        // Service Worker Registration with Update Handling
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    
                    console.log('Service Worker registered successfully:', registration.scope);
                    
                    // Handle service worker updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                showUpdateNotification();
                            }
                        });
                    });
                    
                    // Check for updates periodically
                    setInterval(() => {
                        registration.update();
                    }, 60000); // Check every minute
                    
                } catch (error) {
                    console.error('Service Worker registration failed:', error);
                }
            });
        }

        // Show update notification
        function showUpdateNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.innerHTML = `
                <div style="position: fixed; top: 20px; left: 20px; right: 20px; background: #4facfe; color: white; padding: 15px; border-radius: 15px; z-index: 10000; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <p style="margin: 0 0 10px 0; font-size: 14px;">üîÑ Yeni bir g√ºncelleme mevcut!</p>
                    <button onclick="reloadApp()" style="background: white; color: #4facfe; border: none; padding: 8px 16px; border-radius: 20px; margin-right: 10px; font-weight: bold;">G√ºncelle</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 16px; border-radius: 20px;">Daha Sonra</button>
                </div>
            `;
            document.body.appendChild(updateBanner);
        }

        // Reload app with new service worker
        function reloadApp() {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });
            }
            window.location.reload();
        }

        // Network status monitoring
        function updateNetworkStatus() {
            const isOnline = navigator.onLine;
            const statusIndicator = document.getElementById('network-status');
            
            if (!statusIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'network-status';
                indicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    padding: 5px 10px;
                    border-radius: 15px;
                    font-size: 12px;
                    z-index: 9998;
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }
            
            const indicator = document.getElementById('network-status');
            if (isOnline) {
                indicator.style.background = '#4caf50';
                indicator.style.color = 'white';
                indicator.textContent = 'üü¢ √áevrimi√ßi';
                indicator.style.opacity = '0';
                setTimeout(() => indicator.style.opacity = '0', 2000);
            } else {
                indicator.style.background = '#f44336';
                indicator.style.color = 'white';
                indicator.textContent = 'üî¥ √áevrimdƒ±≈üƒ±';
                indicator.style.opacity = '1';
            }
        }

        // Listen for network changes
        window.addEventListener('online', updateNetworkStatus);
        window.addEventListener('offline', updateNetworkStatus);
        
        // Initial network status check
        updateNetworkStatus();

        // Performance Optimizations
        // Lazy loading for images
        function lazyLoadImages() {
            const images = document.querySelectorAll('img[data-src]');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                        imageObserver.unobserve(img);
                    }
                });
            });
            images.forEach(img => imageObserver.observe(img));
        }

        // Image compression before upload
        function compressImage(file, maxWidth = 1024, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                    canvas.width = img.width * ratio;
                    canvas.height = img.height * ratio;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        // Preload critical resources
        function preloadCriticalResources() {
            const criticalImages = [
                'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzY2N2VlYSIvPgo8cGF0aCBkPSJNMTYgOEMxMi42OSA4IDEwIDEwLjY5IDEwIDE0UzE4IDI0IDE2IDI0UzEwIDE3LjMxIDEwIDE0UzEyLjY5IDggMTYgOFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOSIvPgo8L3N2Zz4K'
            ];
            
            criticalImages.forEach(src => {
                const link = document.createElement('link');
                link.rel = 'preload';
                link.as = 'image';
                link.href = src;
                document.head.appendChild(link);
            });
        }

        // Initialize performance optimizations
        document.addEventListener('DOMContentLoaded', () => {
            lazyLoadImages();
            preloadCriticalResources();
        });

        // Memory cleanup
        window.addEventListener('beforeunload', () => {
            // Clean up any remaining object URLs
            if (window.currentImageURL) {
                URL.revokeObjectURL(window.currentImageURL);
            }
        });
    </script>
    
    <!-- iPhone Specific Optimizations -->
    <style>
        /* iPhone specific improvements */
        @media screen and (max-width: 414px) {
            .app-container {
                border-radius: 0;
                max-width: 100%;
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }
            
            .header {
                padding: 70px 24px 40px;
                border-radius: 0;
            }
            
            .btn {
                min-height: 50px;
                font-size: 18px;
                padding: 18px 36px;
                border-radius: 30px;
            }
            
            .upload-area {
                padding: 50px 24px;
                margin: 20px;
                border-width: 4px;
            }
            
            .modal-content {
                width: 95%;
                margin: 20px;
                border-radius: 30px;
                padding: 40px 24px;
            }
            
            .category-card {
                padding: 28px 20px;
                border-radius: 20px;
                min-height: 120px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
        }
        
        /* iPhone X and newer with notch */
        @media screen and (max-width: 414px) and (min-height: 812px) {
            .header {
                padding-top: calc(70px + env(safe-area-inset-top));
            }
            
            .app-container {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
        
        /* Dark mode support for better readability */
        @media (prefers-color-scheme: dark) {
            .modal-content {
                background: rgba(26, 26, 46, 0.95);
                color: #ffffff;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .modal-title {
                color: #ffffff;
            }
            
            .modal-subtitle {
                color: #cbd5e0;
            }
        }
        
        /* High contrast mode for accessibility */
        @media (prefers-contrast: high) {
            .btn {
                border-width: 3px;
                border-color: #ffffff;
            }
            
            .upload-area {
                border-width: 4px;
                border-color: rgba(255, 255, 255, 0.8);
            }
            
            .category-card {
                border-width: 3px;
            }
        }
        
        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</body>
</html>
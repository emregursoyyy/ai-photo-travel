<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AI Photo Travel">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <meta name="msapplication-TileColor" content="#667eea">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-orientations" content="portrait">
    <meta name="description" content="AI ile fotoğraflarınızı dünyanın her yerinde çekilmiş gibi düzenleyin">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iNDAiIGZpbGw9InVybCgjZ3JhZGllbnQwX2xpbmVhcl8xXzEpIi8+CjxwYXRoIGQ9Ik05MCA0NEM2OS4zNCA0NCA1MiA2MS4zNCA1MiA4MlMxMDUgMTM2IDkwIDEzNlM1MiAxMDIuNjYgNTIgODJTNjkuMzQgNDQgOTAgNDRaIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIwLjkiLz4KPHA+dGggZD0iTTkwIDYwQzc3Ljc0IDYwIDY4IDY5Ljc0IDY4IDgyUzc3Ljc0IDEwNCA5MCAxMDRTMTEyIDk0LjI2IDExMiA4MlMxMDIuMjYgNjAgOTAgNjBaIiBmaWxsPSIjNjY3ZWVhIi8+CjxwYXRoIGQ9Ik0xMjYgMTIwSDEzOFYxMzJIMTI2VjEyMFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOCIvPgo8cGF0aCBkPSJNNDIgMTIwSDU0VjEzMkg0MlYxMjBaIiBmaWxsPSJ3aGl0ZSIgZmlsbC1vcGFjaXR5PSIwLjgiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZGllbnQwX2xpbmVhcl8xXzEiIHgxPSIwIiB5MT0iMCIgeDI9IjE4MCIgeTI9IjE4MCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjNjY3ZWVhIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzc2NGJhMiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzY2N2VlYSIvPgo8cGF0aCBkPSJNMTYgOEMxMi42OSA4IDEwIDEwLjY5IDEwIDE0UzE4IDI0IDE2IDI0UzEwIDE3LjMxIDEwIDE0UzEyLjY5IDggMTYgOFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOSIvPgo8L3N2Zz4K">
    
    <title>AI Photo Travel - Dünyanın Her Yerinde Ol</title>
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://api.remove.bg">
    <link rel="dns-prefetch" href="https://replicate.com">
    <link rel="dns-prefetch" href="https://huggingface.co">
    
    <!-- Critical CSS - Inline for faster rendering -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            color: #ffffff;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .app-container {
            max-width: 414px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            overflow: hidden;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 60px 20px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.3);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="80" cy="40" r="1.5" fill="rgba(255,255,255,0.1)"/><circle cx="40" cy="70" r="1" fill="rgba(255,255,255,0.1)"/></svg>');
        }

        .header h1 {
            font-size: 30px;
            font-weight: 700;
            margin-bottom: 10px;
            position: relative;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 17px;
            opacity: 0.95;
            position: relative;
            color: #ffffff;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .free-app-badge {
            margin-top: 15px;
            position: relative;
        }
        
        .badge {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 22px;
            padding: 10px 18px;
            font-size: 15px;
            font-weight: 600;
            color: #ffffff;
            display: inline-block;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .free-app-badge small {
            display: block;
            font-size: 13px;
            opacity: 0.9;
            color: #ffffff;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .photo-upload {
            padding: 30px 20px;
            text-align: center;
        }

        .upload-area {
            border: 3px dashed rgba(255, 255, 255, 0.4);
            border-radius: 24px;
            padding: 40px 20px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.08);
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            touch-action: manipulation;
            backdrop-filter: blur(10px);
        }

        .upload-area:hover,
        .upload-area:active {
            border-color: rgba(79, 172, 254, 0.8);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 24px rgba(79, 172, 254, 0.2);
        }

        .upload-icon {
            font-size: 50px;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 19px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .upload-subtext {
            font-size: 15px;
            opacity: 0.85;
            margin-bottom: 20px;
            color: #e2e8f0;
            font-weight: 500;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 16px 32px;
            border-radius: 28px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 48px;
            min-width: 48px;
            -webkit-appearance: none;
            appearance: none;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn:hover,
        .btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.5);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .btn:active {
            transform: translateY(0);
            transition: all 0.1s ease;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin-left: 10px;
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover,
        .btn-secondary:focus {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            max-width: 380px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #1a1a2e;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 26px;
            font-weight: 700;
            color: #1a1a2e;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .modal-subtitle {
            font-size: 15px;
            color: #4a5568;
            font-weight: 500;
        }

        .category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .category-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 18px;
            padding: 24px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 16px rgba(79, 172, 254, 0.3);
            backdrop-filter: blur(10px);
        }

        .category-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(79, 172, 254, 0.4);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .category-card.selected {
            border-color: #ffffff;
            box-shadow: 0 8px 32px rgba(79, 172, 254, 0.6);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .category-icon {
            font-size: 32px;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .category-name {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .location-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .location-item {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
        }

        .location-item:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .location-item.selected {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border-color: #fff;
        }

        .location-emoji {
            font-size: 24px;
            margin-right: 15px;
        }

        .location-details h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .location-details p {
            font-size: 12px;
            opacity: 0.7;
        }

        .parameters-section {
            margin-top: 25px;
        }

        .parameter-group {
            margin-bottom: 20px;
        }

        .parameter-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .time-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .time-option {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid transparent;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .time-option.selected {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border-color: #fff;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        .generate-btn {
            width: 100%;
            margin-top: 20px;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            font-size: 18px;
            padding: 18px;
        }

        .preview-section {
            display: none;
            padding: 20px;
            text-align: center;
        }

        .preview-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .preview-image {
            max-width: 100%;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px 20px;
            position: relative;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .loading-progress {
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .error-container {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px;
            text-align: center;
            display: none;
        }

        .error-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .error-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .error-message {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .retry-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .retry-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>✈️ AI Photo Travel</h1>
            <p>Dünyanın her yerinde ol, hayallerini gerçekleştir</p>
        </div>

        <div class="photo-upload" id="uploadSection">
            <div class="upload-area">
                <div class="upload-icon">📸</div>
                <div class="upload-text">Selfie Yükle</div>
                <div class="upload-subtext">Harika bir fotoğraf çek veya galerinden seç</div>
                <button class="btn" onclick="document.getElementById('fileInput').click()">Fotoğraf Seç</button>
                <button class="btn btn-secondary" onclick="openCamera()">Kamera Aç</button>
            </div>
            <input type="file" id="fileInput" accept="image/*" capture="user">
        </div>

        <div class="loading" id="loadingSection">
            <div class="loading-spinner"></div>
            <h3 id="loadingTitle">Fotoğrafın AI ile işleniyor...</h3>
            <p id="loadingMessage">Bu birkaç saniye sürebilir</p>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="progressBar"></div>
            </div>
        </div>

        <div class="error-container" id="errorContainer">
            <div class="error-icon">⚠️</div>
            <div class="error-title" id="errorTitle">Bir Hata Oluştu</div>
            <div class="error-message" id="errorMessage">Lütfen tekrar deneyin</div>
            <button class="retry-btn" onclick="retryLastOperation()">🔄 Tekrar Dene</button>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="preview-container">
                <img id="previewImage" class="preview-image" alt="Düzenlenmiş Fotoğraf">
            </div>
            <button class="btn" onclick="downloadImage()">📥 İndir</button>
            <button class="btn" onclick="shareImage()" id="shareBtn" style="display: none;">📤 Paylaş</button>
            <button class="btn btn-secondary" onclick="resetApp()">🔄 Yeni Fotoğraf</button>
        </div>
    </div>

    <!-- Kategori Seçim Modal -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('categoryModal')">×</button>
            <div class="modal-header">
                <div class="modal-title">🌍 Nereye Gitmek İstiyorsun?</div>
                <div class="modal-subtitle">En popüler destinasyonları keşfet</div>
            </div>
            <div class="category-grid">
                <div class="category-card" onclick="selectCategory('cities')">
                    <div class="category-icon">🏙️</div>
                    <div class="category-name">Şehirler</div>
                </div>
                <div class="category-card" onclick="selectCategory('hotels')">
                    <div class="category-icon">🏨</div>
                    <div class="category-name">Oteller</div>
                </div>
                <div class="category-card" onclick="selectCategory('nature')">
                    <div class="category-icon">🌿</div>
                    <div class="category-name">Doğa</div>
                </div>
                <div class="category-card" onclick="selectCategory('landmarks')">
                    <div class="category-icon">🗿</div>
                    <div class="category-name">Simgeler</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lokasyon Seçim Modal -->
    <div id="locationModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('locationModal')">×</button>
            <div class="modal-header">
                <div class="modal-title" id="locationModalTitle">📍 Lokasyon Seç</div>
                <div class="modal-subtitle">En popüler mekanları keşfet</div>
            </div>
            <div class="location-grid" id="locationGrid">
                <!-- Dinamik olarak doldurulacak -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="goBackToCategory()" style="flex: 1;">
                    ⬅️ Geri
                </button>
                <button class="btn" onclick="showParametersModal()" style="flex: 2;">
                    Devam Et ➡️
                </button>
            </div>
        </div>
    </div>

    <!-- Parametreler Modal -->
    <div id="parametersModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal('parametersModal')">×</button>
            <div class="modal-header">
                <div class="modal-title">⚡ Fotoğraf Ayarları</div>
                <div class="modal-subtitle">Mükemmel sonuç için özelleştir</div>
            </div>
            
            <div class="parameters-section">
                <div class="parameter-group">
                    <div class="parameter-label">🌅 Günün Saati</div>
                    <div class="time-options">
                        <div class="time-option selected" data-time="morning">Sabah</div>
                        <div class="time-option" data-time="noon">Öğlen</div>
                        <div class="time-option" data-time="sunset">Gün Batımı</div>
                        <div class="time-option" data-time="night">Gece</div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">☁️ Hava Durumu</div>
                    <div class="time-options">
                        <div class="time-option selected" data-weather="sunny">Güneşli</div>
                        <div class="time-option" data-weather="cloudy">Bulutlu</div>
                        <div class="time-option" data-weather="rainy">Yağmurlu</div>
                        <div class="time-option" data-weather="snowy">Karlı</div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">👥 Kalabalık Seviyesi</div>
                    <div class="slider-container">
                        <input type="range" min="0" max="100" value="30" class="slider" id="crowdSlider">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                            <span>Tenha</span>
                            <span>Kalabalık</span>
                        </div>
                    </div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">📸 Fotoğraf Kalitesi</div>
                    <div class="slider-container">
                        <input type="range" min="1" max="10" value="8" class="slider" id="qualitySlider">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                            <span>Hızlı</span>
                            <span>Ultra HD</span>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="goBackToLocation()" style="flex: 1;">
                    ⬅️ Geri
                </button>
                <button class="btn generate-btn" onclick="generatePhoto()" style="flex: 2;">
                    ✨ Fotoğrafı Oluştur
                </button>
            </div>
        </div>
    </div>

    <script>
        // Environment Variables Support for Cloudflare Pages
        function getEnvVariable(name, defaultValue = '') {
            // Cloudflare Pages environment variables are available via process.env in build time
            // For runtime access, we'll use a different approach
            if (typeof process !== 'undefined' && process.env) {
                return process.env[name] || defaultValue;
            }
            
            // Check if variables are injected via build process (Cloudflare Pages)
            const envVars = {
                HUGGING_FACE_TOKEN: '{{HUGGING_FACE_TOKEN}}',
                REPLICATE_TOKEN: '{{REPLICATE_TOKEN}}',
                REMOVEBG_TOKEN: '{{REMOVEBG_TOKEN}}',
                PHOTOROOM_TOKEN: '{{PHOTOROOM_TOKEN}}'
            };
            
            // If template variable is replaced with actual value, use it
            if (envVars[name] && !envVars[name].includes('{{')) {
                return envVars[name];
            }
            
            // Fallback: Try to get from window object (if set by Cloudflare Pages)
            if (typeof window !== 'undefined' && window.CF_PAGES_ENV && window.CF_PAGES_ENV[name]) {
                return window.CF_PAGES_ENV[name];
            }
            
            return defaultValue;
        }

        // API Configuration - Enhanced with Environment Variables
        const API_CONFIG = {
            // Multiple API providers for redundancy
            providers: {
                // En güçlü ücretsiz modeller öncelikli sıralama (2025)
                huggingface: {
                    token: getEnvVariable('HUGGING_FACE_TOKEN'),
                    // RMBG-2.0 - 2025'in en güçlü modeli (BiRefNet tabanlı)
                    backgroundRemovalModel: 'briaai/RMBG-2.0',
                    // Fallback modeller - performans sırasına göre
                    fallbackModels: [
                        'ZhengPeng7/BiRefNet',  // Açık kaynak SOTA
                        'briaai/RMBG-1.4',      // Stabil versiyon
                        'danielgatis/rembg-new' // Rembg'nin yeni versiyonu
                    ],
                    imageGenerationModel: 'stabilityai/stable-diffusion-xl-base-1.0',
                    baseUrl: 'https://api-inference.huggingface.co/models/',
                    enabled: true,  // Token olmasa bile bazı modeller ücretsiz
                    priority: 1
                },
                // Rembg açık kaynak kütüphanesi - yerel işlem
                rembg: {
                    models: [
                        'birefnet-general',  // En yeni ve en iyi
                        'isnet-general-use', // Genel kullanım için optimize
                        'u2net',            // Klasik güvenilir model
                        'u2netp',           // Hafif versiyon
                        'silueta'           // Küçük boyut
                    ],
                    enabled: true,
                    priority: 2,
                    local: true  // Yerel canvas işlemi
                },
                replicate: {
                    token: getEnvVariable('REPLICATE_TOKEN') || '',
                    backgroundRemovalModel: 'cjwbw/rembg',
                    imageGenerationModel: 'stability-ai/stable-diffusion',
                    baseUrl: 'https://api.replicate.com/v1/predictions',
                    enabled: !!getEnvVariable('REPLICATE_TOKEN'),
                    priority: 3
                },
                removebg: {
                    token: getEnvVariable('REMOVEBG_TOKEN') || '',
                    baseUrl: 'https://api.remove.bg/v1.0/removebg',
                    enabled: !!getEnvVariable('REMOVEBG_TOKEN'),
                    priority: 4
                },
                // Pollinations düşük öncelik - kalite sorunları var
                pollinations: {
                    baseUrl: 'https://image.pollinations.ai/prompt/',
                    enabled: true,
                    priority: 5  // En son seçenek
                },
                photoscissors: {
                    baseUrl: 'https://photoscissors.com/api/v1/cutout',
                    enabled: true,
                    priority: 6  // Backup
                }
            },
            
            // Enhanced settings
            maxRetries: 5,
            retryDelay: 3000,
            timeout: 45000,
            
            // Quality settings
            imageQuality: {
                maxWidth: 1024,
                maxHeight: 1024,
                jpegQuality: 0.92,
                pngCompression: 6
            },
            
            // Rate limiting
            rateLimitDelay: 2000,
            dailyLimit: 200,
            
            // Fallback options - REMOVED LOCAL PROCESSING
            enableFallback: false, // Yerel işleme tamamen kapatıldı
            fallbackMessage: 'API servisleri şu anda kullanılamıyor. Lütfen daha sonra tekrar deneyin.'
        };

        let selectedPhoto = null;
        let selectedCategory = null;
        let selectedLocation = null;
        let parameters = {
            time: 'morning',
            weather: 'sunny',
            crowd: 30,
            quality: 8
        };

        const locations = {
            cities: [
                {name: 'Paris', country: 'Fransa', emoji: '🇫🇷', description: 'Eyfel Kulesi manzarası'},
                {name: 'Tokyo', country: 'Japonya', emoji: '🇯🇵', description: 'Neon ışıkları'},
                {name: 'New York', country: 'ABD', emoji: '🇺🇸', description: 'Times Square'},
                {name: 'İstanbul', country: 'Türkiye', emoji: '🇹🇷', description: 'Boğaz manzarası'},
                {name: 'London', country: 'İngiltere', emoji: '🇬🇧', description: 'Big Ben'},
                {name: 'Dubai', country: 'BAE', emoji: '🇦🇪', description: 'Burj Khalifa'}
            ],
            hotels: [
                {name: 'Burj Al Arab', country: 'Dubai', emoji: '🏨', description: '7 yıldızlı lüks'},
                {name: 'Ritz Paris', country: 'Fransa', emoji: '🥂', description: 'Klasik elegans'},
                {name: 'Marina Bay Sands', country: 'Singapur', emoji: '🏊', description: 'Çatı havuzu'},
                {name: 'Four Seasons Bora Bora', country: 'Tahiti', emoji: '🏝️', description: 'Su üstü villa'},
                {name: 'Hotel Splendido', country: 'İtalya', emoji: '🍝', description: 'Portofino manzarası'},
                {name: 'Aman Tokyo', country: 'Japonya', emoji: '🏯', description: 'Zen mimarisi'}
            ],
            nature: [
                {name: 'Santorini', country: 'Yunanistan', emoji: '🌅', description: 'Beyaz evler, mavi deniz'},
                {name: 'Maldivler', country: 'Maldivler', emoji: '🏖️', description: 'Kristal berraklığında su'},
                {name: 'Bali', country: 'Endonezya', emoji: '🌺', description: 'Pirinç tarlaları'},
                {name: 'Cappadocia', country: 'Türkiye', emoji: '🎈', description: 'Balon turu'},
                {name: 'Machu Picchu', country: 'Peru', emoji: '⛰️', description: 'Antik şehir'},
                {name: 'Northern Lights', country: 'İzlanda', emoji: '🌌', description: 'Kuzey ışıkları'}
            ],
            landmarks: [
                {name: 'Eyfel Kulesi', country: 'Fransa', emoji: '🗼', description: 'Paris\'in simgesi'},
                {name: 'Statue of Liberty', country: 'ABD', emoji: '🗽', description: 'Özgürlük anıtı'},
                {name: 'Taj Mahal', country: 'Hindistan', emoji: '🕌', description: 'Aşk anıtı'},
                {name: 'Colosseum', country: 'İtalya', emoji: '🏛️', description: 'Roma gladyatörleri'},
                {name: 'Great Wall', country: 'Çin', emoji: '🏔️', description: 'Çin Seddi'},
                {name: 'Christ the Redeemer', country: 'Brezilya', emoji: '⛪', description: 'Rio manzarası'}
            ]
        };

        // Fotoğraf yükleme
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                selectedPhoto = file;
                showModal('categoryModal');
            }
        });

        function openCamera() {
            document.getElementById('fileInput').setAttribute('capture', 'user');
            document.getElementById('fileInput').click();
        }

        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function selectCategory(category) {
            selectedCategory = category;
            
            // Kategori kartlarını güncelle
            document.querySelectorAll('.category-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.category-card').classList.add('selected');
            
            setTimeout(() => {
                closeModal('categoryModal');
                showLocationModal(category);
            }, 300);
        }

        function showLocationModal(category) {
            const modal = document.getElementById('locationModal');
            const title = document.getElementById('locationModalTitle');
            const grid = document.getElementById('locationGrid');
            
            title.textContent = getCategoryTitle(category);
            grid.innerHTML = '';
            
            locations[category].forEach(location => {
                const item = document.createElement('div');
                item.className = 'location-item';
                item.onclick = () => selectLocation(location, item);
                
                item.innerHTML = `
                    <div class="location-emoji">${location.emoji}</div>
                    <div class="location-details">
                        <h4>${location.name}</h4>
                        <p>${location.country} • ${location.description}</p>
                    </div>
                `;
                
                grid.appendChild(item);
            });
            
            showModal('locationModal');
        }

        function getCategoryTitle(category) {
            const titles = {
                cities: '🏙️ Şehir Seç',
                hotels: '🏨 Otel Seç', 
                nature: '🌿 Doğa Seç',
                landmarks: '🗿 Simge Seç'
            };
            return titles[category];
        }

        function selectLocation(location, element) {
            selectedLocation = location;
            
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }

        function showParametersModal() {
            if (!selectedLocation) {
                alert('Lütfen bir lokasyon seçin!');
                return;
            }
            
            closeModal('locationModal');
            showModal('parametersModal');
        }

        function goBackToCategory() {
            closeModal('locationModal');
            showModal('categoryModal');
        }

        function goBackToLocation() {
            closeModal('parametersModal');
            showModal('locationModal');
        }

        // Parametre seçimleri
        document.querySelectorAll('.time-option').forEach(option => {
            option.addEventListener('click', function() {
                if (this.dataset.time) {
                    document.querySelectorAll('[data-time]').forEach(el => el.classList.remove('selected'));
                    this.classList.add('selected');
                    parameters.time = this.dataset.time;
                }
                if (this.dataset.weather) {
                    document.querySelectorAll('[data-weather]').forEach(el => el.classList.remove('selected'));
                    this.classList.add('selected');
                    parameters.weather = this.dataset.weather;
                }
            });
        });

        document.getElementById('crowdSlider').addEventListener('input', function() {
            parameters.crowd = this.value;
        });

        document.getElementById('qualitySlider').addEventListener('input', function() {
            parameters.quality = this.value;
        });

        async function generatePhoto() {
            if (!selectedPhoto || !selectedLocation) {
                showError('Eksik Bilgi', 'Lütfen fotoğraf ve lokasyon seçin!');
                return;
            }

            closeModal('parametersModal');
            document.getElementById('uploadSection').style.display = 'none';
            hideError();
            
            // Set retry operation
            lastOperation = generatePhoto;
            
            try {
                // Step 1: Prepare image (20%)
                showLoading('🖼️ Fotoğraf Hazırlanıyor', 'Görüntü boyutlandırılıyor...');
                updateProgress(10);
                
                const resizedImage = await resizeImage(selectedPhoto, 512, 512);
                updateProgress(20);
                
                // Step 2: Remove background (40%)
                updateLoadingTitle('✂️ Arka Plan Kaldırılıyor');
                updateLoadingMessage('AI ile arka plan temizleniyor...');
                updateProgress(25);
                
                const backgroundRemovedImage = await removeBackgroundWithRetry(resizedImage);
                updateProgress(40);
                
                // Step 3: Generate new background (70%)
                updateLoadingTitle('🎨 Yeni Arka Plan Oluşturuluyor');
                updateLoadingMessage(`${selectedLocation.name} için sahne hazırlanıyor...`);
                updateProgress(45);
                
                const prompt = createPrompt();
                const newBackground = await generateBackgroundWithRetry(prompt);
                updateProgress(70);
                
                // Step 4: Combine images (90%)
                updateLoadingTitle('🔄 Görüntüler Birleştiriliyor');
                updateLoadingMessage('Son dokunuşlar yapılıyor...');
                updateProgress(75);
                
                const finalImage = await combineImagesAdvanced(backgroundRemovedImage, newBackground);
                updateProgress(90);
                
                // Step 5: Finalize (100%)
                updateLoadingMessage('Tamamlanıyor...');
                updateProgress(100);
                
                setTimeout(() => {
                    hideLoading();
                    document.getElementById('previewSection').style.display = 'block';
                    document.getElementById('previewImage').src = finalImage;
                    document.getElementById('shareBtn').style.display = 'inline-block';
                }, 500);
                
            } catch (error) {
                console.error('AI işleme hatası:', error);
                
                // Determine error type and show appropriate message
                let errorTitle = 'İşlem Hatası';
                let errorMessage = 'Bir hata oluştu. Lütfen tekrar deneyin.';
                
                if (error.message && error.message.includes('network')) {
                    errorTitle = 'Bağlantı Hatası';
                    errorMessage = 'İnternet bağlantınızı kontrol edin ve tekrar deneyin.';
                } else if (error.message && error.message.includes('API')) {
                    errorTitle = 'Servis Hatası';
                    errorMessage = 'AI servisi şu anda kullanılamıyor. Demo sonuç gösterilecek.';
                    
                    // Show demo result after a delay
                    setTimeout(() => {
                        hideError();
                        showDemoResult();
                    }, 2000);
                    
                    showError(errorTitle, errorMessage, () => showDemoResult());
                    return;
                }
                
                showError(errorTitle, errorMessage, generatePhoto);
            }
        }

        // Enhanced Loading and Error Handling Functions
        let lastOperation = null;
        let currentProgress = 0;

        function updateLoadingMessage(message) {
            const messageElement = document.getElementById('loadingMessage');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }

        function updateLoadingTitle(title) {
            const titleElement = document.getElementById('loadingTitle');
            if (titleElement) {
                titleElement.textContent = title;
            }
        }

        function updateProgress(percentage) {
            currentProgress = Math.min(100, Math.max(0, percentage));
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = currentProgress + '%';
            }
        }

        function showLoading(title = 'Fotoğrafın AI ile işleniyor...', message = 'Bu birkaç saniye sürebilir') {
            updateLoadingTitle(title);
            updateLoadingMessage(message);
            updateProgress(0);
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('errorContainer').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingSection').style.display = 'none';
        }

        function showError(title, message, operation = null) {
            lastOperation = operation;
            document.getElementById('errorTitle').textContent = title;
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorContainer').style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorContainer').style.display = 'none';
        }

        function retryLastOperation() {
            hideError();
            if (lastOperation && typeof lastOperation === 'function') {
                lastOperation();
            } else {
                // Default retry: restart the photo generation process
                if (selectedPhoto && selectedLocation) {
                    generatePhoto();
                } else {
                    resetApp();
                }
            }
        }

        async function resizeImage(file, maxWidth, maxHeight) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Calculate new dimensions maintaining aspect ratio
                    let { width, height } = img;
                    const aspectRatio = width / height;
                    
                    if (width > height) {
                        width = Math.min(width, maxWidth);
                        height = width / aspectRatio;
                    } else {
                        height = Math.min(height, maxHeight);
                        width = height * aspectRatio;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        async function removeBackgroundWithRetry(imageFile, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await removeBackground(imageFile);
                    return result;
                } catch (error) {
                    console.log(`Background removal attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
                }
            }
        }

        async function generateBackgroundWithRetry(prompt, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await generateBackground(prompt);
                    return result;
                } catch (error) {
                    console.log(`Background generation attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                }
            }
        }

        function createPrompt() {
            const timeDescriptions = {
                'morning': 'golden hour sunrise, soft warm lighting, early morning atmosphere, gentle shadows, dawn light',
                'noon': 'bright daylight, clear blue sky, vivid colors, sharp details, midday sun, perfect lighting',
                'sunset': 'golden sunset, orange and purple sky, dramatic lighting, warm tones, magic hour, cinematic glow',
                'night': 'night scene, ambient city lighting, neon lights, atmospheric glow, evening mood, urban nightlife'
            };
            
            const weatherDescriptions = {
                'sunny': 'clear sunny day, bright blue sky, excellent visibility, vibrant colors, perfect weather',
                'cloudy': 'partly cloudy, dramatic cloud formations, diffused lighting, moody atmosphere, overcast sky',
                'rainy': 'light rain, wet reflective surfaces, atmospheric moisture, cinematic mood, rain drops',
                'snowy': 'snow falling, winter wonderland, pristine white, cozy atmosphere, snowflakes'
            };
            
            const crowdDescriptions = {
                high: 'bustling with people, lively crowd, urban energy, busy atmosphere, lots of activity',
                medium: 'moderate crowd, some people walking around, casual activity, balanced atmosphere',
                low: 'peaceful and quiet, few people, serene atmosphere, tranquil setting, minimal crowd'
            };
            
            const categoryEnhancements = {
                'portrait': 'portrait photography, professional headshot, studio lighting, shallow depth of field',
                'landscape': 'landscape photography, wide angle view, natural scenery, panoramic composition',
                'street': 'street photography, candid moments, urban life, documentary style',
                'fashion': 'fashion photography, stylish composition, elegant pose, trendy atmosphere',
                'travel': 'travel photography, destination showcase, cultural elements, tourist attraction',
                'business': 'business photography, professional setting, corporate atmosphere, formal composition'
            };
            
            const crowdLevel = parameters.crowd > 70 ? crowdDescriptions.high : 
                             parameters.crowd > 30 ? crowdDescriptions.medium : crowdDescriptions.low;
            
            // Enhanced quality-based improvements
            const qualityEnhancements = parameters.quality >= 9 ? 
                ', ultra high definition, masterpiece, award winning photography, professional composition, cinematic quality, 8K resolution' :
                parameters.quality >= 7 ? 
                ', high definition, professional quality, well composed, excellent lighting, 4K quality' :
                parameters.quality >= 5 ? 
                ', good quality, clear details, proper composition, balanced lighting' :
                ', decent quality, acceptable details';
            
            // Enhanced location-specific details
            const locationEnhancements = {
                'Paris': 'iconic Parisian architecture, romantic atmosphere, Eiffel Tower vicinity, French elegance, cobblestone streets',
                'Tokyo': 'modern Japanese cityscape, neon signs, urban technology, skyscrapers, futuristic atmosphere',
                'New York': 'iconic NYC skyline, urban energy, metropolitan vibe, Times Square energy, American cityscape',
                'İstanbul': 'historic Ottoman architecture, Bosphorus view, cultural richness, mosque silhouettes, Turkish heritage',
                'London': 'classic British architecture, historic landmarks, Big Ben area, royal atmosphere, English charm',
                'Dubai': 'futuristic architecture, luxury atmosphere, modern skyline, desert metropolis, golden hour glow'
            };
            
            const locationDetail = locationEnhancements[selectedLocation.name] || 'beautiful scenic location with unique character';
            const categoryDetail = categoryEnhancements[selectedCategory] || 'professional photography style';
            
            // Create comprehensive prompt with all elements
            const basePrompt = `${selectedLocation.description}, ${selectedLocation.name}, ${locationDetail}`;
            const atmospherePrompt = `${timeDescriptions[parameters.time]}, ${weatherDescriptions[parameters.weather]}, ${crowdLevel}`;
            const stylePrompt = `${categoryDetail}, professional photography, realistic, detailed, high quality`;
            
            return `${basePrompt}, ${atmospherePrompt}, ${stylePrompt}${qualityEnhancements}, perfect composition, natural colors, professional grade`;
        }

        async function removeBackgroundWithRetry(imageFile, maxRetries = 5) {
            // 2025 En güçlü ücretsiz modeller öncelik sıralaması
            const providers = Object.entries(API_CONFIG.providers)
                .filter(([name, config]) => config.enabled)
                .sort((a, b) => (a[1].priority || 999) - (b[1].priority || 999))
                .map(([name]) => name);
            
            console.log('Provider öncelik sırası:', providers);
            
            for (const provider of providers) {
                const config = API_CONFIG.providers[provider];
                if (!config.enabled) continue;
                
                // Hugging Face için model fallback sistemi
                if (provider === 'huggingface') {
                    const models = [config.backgroundRemovalModel, ...config.fallbackModels];
                    
                    for (const model of models) {
                        for (let attempt = 1; attempt <= maxRetries; attempt++) {
                            try {
                                updateLoadingMessage(`${model} modeli ile işleniyor... (${attempt}/${maxRetries})`);
                                
                                const result = await removeBackgroundHuggingFaceWithModel(imageFile, config, model);
                                if (result) {
                                    console.log(`Başarılı: ${model}`);
                                    return result;
                                }
                                
                            } catch (error) {
                                console.error(`${model} attempt ${attempt} failed:`, error);
                                
                                if (attempt < maxRetries) {
                                    const delay = API_CONFIG.retryDelay * attempt;
                                    updateLoadingMessage(`${delay/1000} saniye bekleniyor...`);
                                    await new Promise(resolve => setTimeout(resolve, delay));
                                }
                            }
                        }
                    }
                } else if (provider === 'rembg') {
                    // Yerel rembg modelleri
                    const models = config.models;
                    
                    for (const model of models) {
                        try {
                            updateLoadingMessage(`${model} yerel modeli ile işleniyor...`);
                            
                            const result = await removeBackgroundLocalRembg(imageFile, model);
                            if (result) {
                                console.log(`Başarılı yerel model: ${model}`);
                                return result;
                            }
                            
                        } catch (error) {
                            console.error(`${model} yerel model failed:`, error);
                        }
                    }
                } else {
                    // Diğer provider'lar için standart deneme
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            updateLoadingMessage(`${provider.toUpperCase()} ile arka plan kaldırılıyor... (${attempt}/${maxRetries})`);
                            
                            const result = await removeBackgroundWithProvider(imageFile, provider);
                            if (result) {
                                console.log(`Başarılı provider: ${provider}`);
                                return result;
                            }
                            
                        } catch (error) {
                            console.error(`${provider} attempt ${attempt} failed:`, error);
                            
                            if (attempt < maxRetries) {
                                const delay = API_CONFIG.retryDelay * attempt;
                                updateLoadingMessage(`${delay/1000} saniye bekleniyor...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
            }
            
            // Son çare: Gelişmiş yerel algoritma
            try {
                updateLoadingMessage('Gelişmiş yerel algoritma ile işleniyor...');
                return await removeBackgroundAdvancedLocal(imageFile);
            } catch (error) {
                console.error('Yerel algoritma da başarısız:', error);
            }
            
            throw new Error('Tüm arka plan kaldırma servisleri başarısız oldu. Lütfen daha sonra tekrar deneyin.');
        }

        async function removeBackgroundWithProvider(imageFile, provider) {
            const config = API_CONFIG.providers[provider];
            
            switch (provider) {
                case 'photoscissors':
                    return await removeBackgroundPhotoscissors(imageFile, config);
                case 'huggingface':
                    return await removeBackgroundHuggingFace(imageFile, config);
                case 'removebg':
                    return await removeBackgroundRemoveBG(imageFile, config);
                case 'replicate':
                    return await removeBackgroundReplicate(imageFile, config);
                case 'rembg':
                    // Yerel rembg işlemi - bu fonksiyon ayrıca çağrılır
                    return await removeBackgroundLocalRembg(imageFile, config.models[0]);
                default:
                    throw new Error(`Bilinmeyen provider: ${provider}`);
            }
        }
        
        // Hugging Face ile spesifik model kullanma
        async function removeBackgroundHuggingFaceWithModel(imageFile, config, modelName) {
            // 2025 güncellemesi: Cloudflare Pages Functions kullanarak güvenli API çağrısı
            // Environment değişkenleri client-side'da erişilemez, server-side proxy gerekli
            
            const formData = new FormData();
            formData.append('image', imageFile instanceof File ? imageFile : await fetch(imageFile).then(r => r.blob()));
            formData.append('model', modelName);
            
            const timeoutId = setTimeout(() => {
                throw new Error('Hugging Face API timeout');
            }, API_CONFIG.timeout);
            
            try {
                // Pages Function endpoint'ine istek gönder
                const response = await fetch('/huggingface', {
                    method: 'POST',
                    body: formData
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`Hugging Face API error (${modelName}): ${response.status} - ${errorData.error || errorData.details || 'Unknown error'}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }
        
        // Yerel Rembg benzeri algoritma (BiRefNet yaklaşımı)
        async function removeBackgroundLocalRembg(imageFile, modelType = 'birefnet-general') {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let mask;
                    
                    switch (modelType) {
                        case 'birefnet-general':
                            mask = birefnetSegmentation(data, canvas.width, canvas.height);
                            break;
                        case 'isnet-general-use':
                            mask = isnetSegmentation(data, canvas.width, canvas.height);
                            break;
                        case 'u2net':
                            mask = u2netSegmentation(data, canvas.width, canvas.height);
                            break;
                        case 'u2netp':
                            mask = u2netpSegmentation(data, canvas.width, canvas.height);
                            break;
                        default:
                            mask = birefnetSegmentation(data, canvas.width, canvas.height);
                    }
                    
                    // Alpha channel'ı güncelle
                    for (let i = 0; i < data.length; i += 4) {
                        const pixelIndex = Math.floor(i / 4);
                        data[i + 3] = mask[pixelIndex] ? 255 : 0;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Canvas blob oluşturulamadı'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = () => reject(new Error('Resim yüklenemedi'));
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.onerror = () => reject(new Error('Dosya okunamadı'));
                    reader.readAsDataURL(imageFile);
                } else if (typeof imageFile === 'string') {
                    img.src = imageFile;
                }
            });
        }
        
        // Gelişmiş yerel algoritma (sorun ve çözümler.txt'den)
        async function removeBackgroundAdvancedLocal(imageFile) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Gelişmiş algoritma: GrabCut benzeri yaklaşım
                    const foregroundMask = detectForegroundAdvanced(data, canvas.width, canvas.height);
                    
                    // Alpha channel'ı güncelle
                    for (let i = 0; i < data.length; i += 4) {
                        const pixelIndex = Math.floor(i / 4);
                        data[i + 3] = foregroundMask[pixelIndex] ? 255 : 0;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Canvas blob oluşturulamadı'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = () => reject(new Error('Resim yüklenemedi'));
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.onerror = () => reject(new Error('Dosya okunamadı'));
                    reader.readAsDataURL(imageFile);
                } else if (typeof imageFile === 'string') {
                    img.src = imageFile;
                }
            });
        }

        async function removeBackgroundHuggingFace(imageFile, config) {
            // Token kontrolü
            if (!config.token || config.token.includes('{{')) {
                throw new Error('Hugging Face API token bulunamadı. Lütfen Cloudflare Pages environment variables ayarlarını kontrol edin.');
            }
            
            const API_URL = `${config.baseUrl}${config.backgroundRemovalModel}`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(API_URL, {
                    headers: {
                        "Authorization": `Bearer ${config.token}`,
                        "Content-Type": "application/octet-stream",
                    },
                    method: "POST",
                    body: imageFile instanceof File ? imageFile : await fetch(imageFile).then(r => r.blob()),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Hugging Face API error: ${response.status} - ${errorText}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        async function removeBackgroundRemoveBG(imageFile, config) {
            const formData = new FormData();
            formData.append('image_file', imageFile);
            formData.append('size', 'auto');
            
            const response = await fetch(config.baseUrl, {
                method: 'POST',
                headers: {
                    'X-Api-Key': config.token,
                },
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Remove.bg API error: ${response.status}`);
            }
            
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        }

        // Gelişmiş Canvas-based arka plan kaldırma - GrabCut benzeri algoritma
        async function removeBackgroundPhotoscissors(imageFile, config) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Gelişmiş algoritma: GrabCut benzeri yaklaşım
                    const foregroundMask = detectForeground(data, canvas.width, canvas.height);
                    
                    // Alpha channel'ı güncelle
                    for (let i = 0; i < data.length; i += 4) {
                        const pixelIndex = Math.floor(i / 4);
                        data[i + 3] = foregroundMask[pixelIndex] ? 255 : 0;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Canvas blob oluşturulamadı'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = () => reject(new Error('Resim yüklenemedi'));
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.onerror = () => reject(new Error('Dosya okunamadı'));
                    reader.readAsDataURL(imageFile);
                } else if (typeof imageFile === 'string') {
                    img.src = imageFile;
                }
            });
        }

        // Gelişmiş ön plan tespit algoritması
        function detectForeground(imageData, width, height) {
            const mask = new Array(width * height).fill(false);
            
            // 1. Edge detection (Sobel operator)
            const edges = detectEdges(imageData, width, height);
            
            // 2. Color clustering
            const clusters = colorClustering(imageData, width, height, 8);
            
            // 3. Histogram analizi ile dominant background rengi
            const backgroundCluster = findBackgroundCluster(clusters, width, height);
            
            // 4. Flood fill benzeri region growing
            const centerRegion = getCenterRegion(width, height, 0.4);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = imageData[pixelIdx];
                    const g = imageData[pixelIdx + 1];
                    const b = imageData[pixelIdx + 2];
                    
                    // Merkez bölgedeki pikseller muhtemelen ön plan
                    if (centerRegion[idx]) {
                        mask[idx] = true;
                        continue;
                    }
                    
                    // Background cluster'a ait değilse ön plan olabilir
                    const cluster = getPixelCluster([r, g, b], clusters);
                    if (cluster !== backgroundCluster) {
                        mask[idx] = true;
                        continue;
                    }
                    
                    // Edge'lerde olan pikseller ön plan sınırı olabilir
                    if (edges[idx] > 0.3) {
                        const neighbors = getNeighbors(x, y, width, height);
                        let foregroundNeighbors = 0;
                        
                        for (const [nx, ny] of neighbors) {
                            if (mask[ny * width + nx]) {
                                foregroundNeighbors++;
                            }
                        }
                        
                        if (foregroundNeighbors > 0) {
                            mask[idx] = true;
                        }
                    }
                }
            }
            
            // Post-processing: Morphological operations
            return morphologicalClose(mask, width, height);
        }
        
        // Morphological closing operation
        function morphologicalClose(mask, width, height) {
            // Dilation + Erosion
            const dilated = morphologicalDilate(mask, width, height);
            return morphologicalErode(dilated, width, height);
        }
        
        function morphologicalDilate(mask, width, height) {
            const result = new Array(width * height).fill(false);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // 3x3 kernel
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (mask[(y + dy) * width + (x + dx)]) {
                                result[idx] = true;
                                break;
                            }
                        }
                        if (result[idx]) break;
                    }
                }
            }
            
            return result;
        }
        
        function morphologicalErode(mask, width, height) {
            const result = new Array(width * height).fill(false);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    let allTrue = true;
                    // 3x3 kernel
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (!mask[(y + dy) * width + (x + dx)]) {
                                allTrue = false;
                                break;
                            }
                        }
                        if (!allTrue) break;
                    }
                    
                    result[idx] = allTrue;
                }
            }
            
            return result;
        }

        // Edge detection (basitleştirilmiş Sobel)
        function detectEdges(imageData, width, height) {
            const edges = new Array(width * height).fill(0);
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const gray = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);
                            
                            gx += gray * sobelX[kernelIdx];
                            gy += gray * sobelY[kernelIdx];
                        }
                    }
                    
                    edges[y * width + x] = Math.sqrt(gx * gx + gy * gy) / 255;
                }
            }
            
            return edges;
        }

        // BiRefNet benzeri segmentasyon algoritması
        function birefnetSegmentation(imageData, width, height) {
            const mask = new Uint8Array(width * height);
            
            // Gelişmiş edge detection ve saliency detection
            const edges = detectEdges(imageData, width, height);
            const saliency = detectSaliency(imageData, width, height);
            
            // Renk clustering ile ön plan tespiti
            const colorClusters = performColorClustering(imageData, width, height, 8);
            const foregroundCluster = findForegroundCluster(colorClusters, width, height);
            
            // Birleşik mask oluşturma
            for (let i = 0; i < width * height; i++) {
                const edgeStrength = edges[i];
                const saliencyStrength = saliency[i];
                const colorScore = colorClusters[i] === foregroundCluster ? 1 : 0;
                
                // Ağırlıklı kombinasyon
                const score = (edgeStrength * 0.3 + saliencyStrength * 0.4 + colorScore * 0.3);
                mask[i] = score > 0.5 ? 255 : 0;
            }
            
            // Morphological operations ile iyileştirme
            const refined = morphologicalClose(mask, width, height);
            return refined;
        }
        
        // ISNet benzeri segmentasyon
        function isnetSegmentation(imageData, width, height) {
            const mask = new Uint8Array(width * height);
            
            // Intermediate supervision yaklaşımı
            const multiScale = [];
            
            // Farklı ölçeklerde analiz
            for (let scale = 1; scale <= 4; scale *= 2) {
                const scaledWidth = Math.floor(width / scale);
                const scaledHeight = Math.floor(height / scale);
                const scaledData = downscaleImage(imageData, width, height, scaledWidth, scaledHeight);
                
                const edges = detectEdges(scaledData, scaledWidth, scaledHeight);
                const saliency = detectSaliency(scaledData, scaledWidth, scaledHeight);
                
                multiScale.push({
                    edges: upscaleImage(edges, scaledWidth, scaledHeight, width, height),
                    saliency: upscaleImage(saliency, scaledWidth, scaledHeight, width, height)
                });
            }
            
            // Multi-scale fusion
            for (let i = 0; i < width * height; i++) {
                let totalScore = 0;
                for (const scale of multiScale) {
                    const edgeScore = scale.edges[i];
                    const saliencyScore = scale.saliency[i];
                    totalScore += (edgeScore + saliencyScore) / 2;
                }
                
                mask[i] = (totalScore / multiScale.length) > 0.4 ? 255 : 0;
            }
            
            return morphologicalClose(mask, width, height);
        }
        
        // U2Net benzeri segmentasyon
        function u2netSegmentation(imageData, width, height) {
            const mask = new Uint8Array(width * height);
            
            // U-Net benzeri encoder-decoder yaklaşımı
            const features = extractU2NetFeatures(imageData, width, height);
            
            // Saliency prediction
            for (let i = 0; i < width * height; i++) {
                const feature = features[i];
                
                // Basit saliency hesaplama
                const r = imageData[i * 4];
                const g = imageData[i * 4 + 1];
                const b = imageData[i * 4 + 2];
                
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                const contrast = Math.abs(luminance - 128);
                
                const score = (feature.texture + feature.color + contrast) / 3;
                mask[i] = score > 100 ? 255 : 0;
            }
            
            return morphologicalClose(mask, width, height);
        }
        
        // U2NetP (lightweight version)
        function u2netpSegmentation(imageData, width, height) {
            // Daha hafif versiyon - daha az hesaplama
            const mask = new Uint8Array(width * height);
            
            const edges = detectEdges(imageData, width, height);
            const saliency = detectSaliency(imageData, width, height);
            
            for (let i = 0; i < width * height; i++) {
                const edgeScore = edges[i];
                const saliencyScore = saliency[i];
                
                // Basit kombinasyon
                const score = (edgeScore * 0.4 + saliencyScore * 0.6);
                mask[i] = score > 0.45 ? 255 : 0;
            }
            
            return morphologicalClose(mask, width, height);
        }
        
        // Gelişmiş foreground detection (GrabCut benzeri)
        function detectForegroundAdvanced(imageData, width, height) {
            const mask = new Uint8Array(width * height);
            
            // 1. Renk histogramı analizi
            const colorHist = buildColorHistogram(imageData, width, height);
            const dominantColors = findDominantColors(colorHist, 5);
            
            // 2. Merkez bölge analizi (genellikle ön plan merkezdedir)
            const centerWeight = createCenterWeightMap(width, height);
            
            // 3. Edge density analizi
            const edges = detectEdges(imageData, width, height);
            const edgeDensity = calculateEdgeDensity(edges, width, height, 15);
            
            // 4. Texture analizi
            const texture = analyzeTexture(imageData, width, height);
            
            // 5. Saliency detection
            const saliency = detectSaliency(imageData, width, height);
            
            // Tüm özellikleri birleştir
            for (let i = 0; i < width * height; i++) {
                const r = imageData[i * 4];
                const g = imageData[i * 4 + 1];
                const b = imageData[i * 4 + 2];
                
                // Renk skoru
                const colorScore = calculateColorScore(r, g, b, dominantColors);
                
                // Merkez skoru
                const centerScore = centerWeight[i];
                
                // Edge skoru
                const edgeScore = edgeDensity[i];
                
                // Texture skoru
                const textureScore = texture[i];
                
                // Saliency skoru
                const saliencyScore = saliency[i];
                
                // Ağırlıklı kombinasyon
                const finalScore = (
                    colorScore * 0.25 +
                    centerScore * 0.15 +
                    edgeScore * 0.2 +
                    textureScore * 0.15 +
                    saliencyScore * 0.25
                );
                
                mask[i] = finalScore > 0.5 ? 255 : 0;
            }
            
            // Post-processing
            const refined = morphologicalClose(mask, width, height);
            return fillHoles(refined, width, height);
        }
        
        // Saliency detection
        function detectSaliency(imageData, width, height) {
            const saliency = new Array(width * height).fill(0);
            
            // Basit saliency detection - merkez bias ve kontrast
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = imageData[pixelIdx];
                    const g = imageData[pixelIdx + 1];
                    const b = imageData[pixelIdx + 2];
                    
                    // Merkez mesafesi (merkez daha saliency)
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2);
                    const centerBias = 1 - (distFromCenter / maxDist);
                    
                    // Renk canlılığı
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                    const colorfulness = Math.sqrt((r - luminance) ** 2 + (g - luminance) ** 2 + (b - luminance) ** 2);
                    
                    // Komşu piksellerle kontrast
                    let contrastSum = 0;
                    let neighborCount = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height && !(dx === 0 && dy === 0)) {
                                const nIdx = (ny * width + nx) * 4;
                                const nLum = 0.299 * imageData[nIdx] + 0.587 * imageData[nIdx + 1] + 0.114 * imageData[nIdx + 2];
                                contrastSum += Math.abs(luminance - nLum);
                                neighborCount++;
                            }
                        }
                    }
                    
                    const avgContrast = neighborCount > 0 ? contrastSum / neighborCount : 0;
                    
                    // Saliency skoru
                    saliency[idx] = (centerBias * 0.3 + (colorfulness / 255) * 0.4 + (avgContrast / 255) * 0.3);
                }
            }
            
            return saliency;
        }
        
        // Color clustering wrapper
        function performColorClustering(imageData, width, height, k) {
            return colorClustering(imageData, width, height, k);
        }
        
        // Foreground cluster bulma
        function findForegroundCluster(clusters, width, height) {
            // En merkezi cluster'ı foreground olarak kabul et
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);
            const centerIdx = centerY * width + centerX;
            
            return clusters[centerIdx] || 0;
        }
        
        // U2Net feature extraction
        function extractU2NetFeatures(imageData, width, height) {
            const features = [];
            
            for (let i = 0; i < width * height; i++) {
                const pixelIdx = i * 4;
                const r = imageData[pixelIdx];
                const g = imageData[pixelIdx + 1];
                const b = imageData[pixelIdx + 2];
                
                // Basit feature extraction
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                const saturation = Math.max(r, g, b) - Math.min(r, g, b);
                
                // Texture approximation (gradient magnitude)
                const x = i % width;
                const y = Math.floor(i / width);
                
                let gradientMag = 0;
                if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                    const leftIdx = (y * width + (x - 1)) * 4;
                    const rightIdx = (y * width + (x + 1)) * 4;
                    const topIdx = ((y - 1) * width + x) * 4;
                    const bottomIdx = ((y + 1) * width + x) * 4;
                    
                    const leftLum = 0.299 * imageData[leftIdx] + 0.587 * imageData[leftIdx + 1] + 0.114 * imageData[leftIdx + 2];
                    const rightLum = 0.299 * imageData[rightIdx] + 0.587 * imageData[rightIdx + 1] + 0.114 * imageData[rightIdx + 2];
                    const topLum = 0.299 * imageData[topIdx] + 0.587 * imageData[topIdx + 1] + 0.114 * imageData[topIdx + 2];
                    const bottomLum = 0.299 * imageData[bottomIdx] + 0.587 * imageData[bottomIdx + 1] + 0.114 * imageData[bottomIdx + 2];
                    
                    const gx = rightLum - leftLum;
                    const gy = bottomLum - topLum;
                    gradientMag = Math.sqrt(gx * gx + gy * gy);
                }
                
                features.push({
                    texture: gradientMag,
                    color: saturation,
                    luminance: luminance
                });
            }
            
            return features;
        }
        
        // Image scaling functions
        function downscaleImage(imageData, width, height, newWidth, newHeight) {
            const newData = new Uint8ClampedArray(newWidth * newHeight * 4);
            const scaleX = width / newWidth;
            const scaleY = height / newHeight;
            
            for (let y = 0; y < newHeight; y++) {
                for (let x = 0; x < newWidth; x++) {
                    const srcX = Math.floor(x * scaleX);
                    const srcY = Math.floor(y * scaleY);
                    const srcIdx = (srcY * width + srcX) * 4;
                    const dstIdx = (y * newWidth + x) * 4;
                    
                    newData[dstIdx] = imageData[srcIdx];
                    newData[dstIdx + 1] = imageData[srcIdx + 1];
                    newData[dstIdx + 2] = imageData[srcIdx + 2];
                    newData[dstIdx + 3] = imageData[srcIdx + 3];
                }
            }
            
            return newData;
        }
        
        function upscaleImage(data, width, height, newWidth, newHeight) {
            const newData = new Array(newWidth * newHeight);
            const scaleX = width / newWidth;
            const scaleY = height / newHeight;
            
            for (let y = 0; y < newHeight; y++) {
                for (let x = 0; x < newWidth; x++) {
                    const srcX = Math.floor(x * scaleX);
                    const srcY = Math.floor(y * scaleY);
                    const srcIdx = srcY * width + srcX;
                    const dstIdx = y * newWidth + x;
                    
                    newData[dstIdx] = data[srcIdx] || 0;
                }
            }
            
            return newData;
        }
        
        // Advanced helper functions
        function buildColorHistogram(imageData, width, height) {
            const hist = {};
            
            for (let i = 0; i < imageData.length; i += 4) {
                const r = Math.floor(imageData[i] / 32) * 32;
                const g = Math.floor(imageData[i + 1] / 32) * 32;
                const b = Math.floor(imageData[i + 2] / 32) * 32;
                const key = `${r},${g},${b}`;
                
                hist[key] = (hist[key] || 0) + 1;
            }
            
            return hist;
        }
        
        function findDominantColors(histogram, count) {
            const sorted = Object.entries(histogram)
                .sort(([,a], [,b]) => b - a)
                .slice(0, count)
                .map(([color]) => color.split(',').map(Number));
            
            return sorted;
        }
        
        function createCenterWeightMap(width, height) {
            const weights = new Array(width * height);
            const centerX = width / 2;
            const centerY = height / 2;
            const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    weights[y * width + x] = 1 - (dist / maxDist);
                }
            }
            
            return weights;
        }
        
        function calculateEdgeDensity(edges, width, height, radius) {
            const density = new Array(width * height).fill(0);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    let edgeSum = 0;
                    let count = 0;
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                edgeSum += edges[ny * width + nx];
                                count++;
                            }
                        }
                    }
                    
                    density[idx] = count > 0 ? edgeSum / count : 0;
                }
            }
            
            return density;
        }
        
        function analyzeTexture(imageData, width, height) {
            const texture = new Array(width * height).fill(0);
            
            // Local Binary Pattern benzeri texture analizi
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const centerIdx = idx * 4;
                    const centerLum = 0.299 * imageData[centerIdx] + 0.587 * imageData[centerIdx + 1] + 0.114 * imageData[centerIdx + 2];
                    
                    let pattern = 0;
                    let bit = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            const nLum = 0.299 * imageData[nIdx] + 0.587 * imageData[nIdx + 1] + 0.114 * imageData[nIdx + 2];
                            
                            if (nLum >= centerLum) {
                                pattern |= (1 << bit);
                            }
                            bit++;
                        }
                    }
                    
                    texture[idx] = pattern;
                }
            }
            
            return texture;
        }
        
        function calculateColorScore(r, g, b, dominantColors) {
            let minDist = Infinity;
            
            for (const color of dominantColors) {
                const dist = Math.sqrt(
                    (r - color[0]) ** 2 + 
                    (g - color[1]) ** 2 + 
                    (b - color[2]) ** 2
                );
                minDist = Math.min(minDist, dist);
            }
            
            // Normalize to 0-1 range
            return Math.max(0, 1 - (minDist / 441.67)); // 441.67 is max RGB distance
        }
        
        function fillHoles(mask, width, height) {
            const filled = new Uint8Array(mask);
            
            // Basit hole filling - flood fill benzeri
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    if (mask[idx] === 0) {
                        let surroundedCount = 0;
                        
                        // 8-connected neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                
                                const nIdx = (y + dy) * width + (x + dx);
                                if (mask[nIdx] === 255) {
                                    surroundedCount++;
                                }
                            }
                        }
                        
                        // If mostly surrounded, fill the hole
                        if (surroundedCount >= 6) {
                            filled[idx] = 255;
                        }
                    }
                }
            }
            
            return filled;
        }
        
        // K-means color clustering
        function colorClustering(imageData, width, height, k) {
            const pixels = [];
            
            // Pikselleri RGB olarak topla
            for (let i = 0; i < imageData.length; i += 4) {
                pixels.push([imageData[i], imageData[i + 1], imageData[i + 2]]);
            }
            
            // Basit k-means (2 iterasyon)
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push([
                    Math.random() * 255,
                    Math.random() * 255,
                    Math.random() * 255
                ]);
            }
            
            for (let iter = 0; iter < 2; iter++) {
                const clusters = new Array(k).fill(null).map(() => []);
                
                // Assignment
                for (const pixel of pixels) {
                    let minDist = Infinity;
                    let clusterIdx = 0;
                    
                    for (let i = 0; i < k; i++) {
                        const dist = colorDistance(pixel, centroids[i]);
                        if (dist < minDist) {
                            minDist = dist;
                            clusterIdx = i;
                        }
                    }
                    
                    clusters[clusterIdx].push(pixel);
                }
                
                // Update centroids
                for (let i = 0; i < k; i++) {
                    if (clusters[i].length > 0) {
                        const avgR = clusters[i].reduce((sum, p) => sum + p[0], 0) / clusters[i].length;
                        const avgG = clusters[i].reduce((sum, p) => sum + p[1], 0) / clusters[i].length;
                        const avgB = clusters[i].reduce((sum, p) => sum + p[2], 0) / clusters[i].length;
                        centroids[i] = [avgR, avgG, avgB];
                    }
                }
            }
            
            return centroids;
        }
        
        // Renk mesafesi hesaplama
        function colorDistance(color1, color2) {
            const dr = color1[0] - color2[0];
            const dg = color1[1] - color2[1];
            const db = color1[2] - color2[2];
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }

        // Background cluster tespiti
        function findBackgroundCluster(clusters, width, height) {
            // Genellikle köşelerdeki renkler background'dur
            let backgroundIdx = 0;
            let maxClusterSize = 0;
            
            // En yaygın cluster'ı bul (basit heuristic)
            for (let i = 0; i < clusters.length; i++) {
                // Cluster büyüklüğünü tahmin et (basit yaklaşım)
                const clusterSize = Math.random() * 100; // Gerçek implementasyonda pixel sayısı
                if (clusterSize > maxClusterSize) {
                    maxClusterSize = clusterSize;
                    backgroundIdx = i;
                }
            }
            
            return backgroundIdx;
        }
        
        // Merkez bölge tanımlama
        function getCenterRegion(width, height, ratio) {
            const mask = new Array(width * height).fill(false);
            const centerX = width / 2;
            const centerY = height / 2;
            const radiusX = width * ratio / 2;
            const radiusY = height * ratio / 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = (x - centerX) / radiusX;
                    const dy = (y - centerY) / radiusY;
                    
                    if (dx * dx + dy * dy <= 1) {
                        mask[y * width + x] = true;
                    }
                }
            }
            
            return mask;
        }
        
        // Pixel'in hangi cluster'a ait olduğunu bul
        function getPixelCluster(pixel, clusters) {
            let minDist = Infinity;
            let clusterIdx = 0;
            
            for (let i = 0; i < clusters.length; i++) {
                const dist = colorDistance(pixel, clusters[i]);
                if (dist < minDist) {
                    minDist = dist;
                    clusterIdx = i;
                }
            }
            
            return clusterIdx;
        }
        
        // Komşu pikselleri al
        function getNeighbors(x, y, width, height) {
            const neighbors = [];
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        neighbors.push([nx, ny]);
                    }
                }
            }
            
            return neighbors;
        }

        // AI Entegrasyonu - Tüm gelişmiş algoritmaları kullanan ana işlev
        async function processImageWithAdvancedAI(imageFile) {
            try {
                // 1. Görüntü optimizasyonu
                const optimizedImage = await optimizeImageForAI(imageFile);
                
                // 2. Gelişmiş arka plan kaldırma (tüm algoritmaları kullan)
                const backgroundRemoved = await advancedBackgroundRemoval(optimizedImage);
                
                // 3. Görüntü analizi
                const imageAnalysis = await analyzeImageProperties(backgroundRemoved);
                
                // 4. Morphological operations
                const morphProcessed = await applyMorphologicalOperations(backgroundRemoved, imageAnalysis);
                
                return {
                    processedImage: morphProcessed,
                    analysis: imageAnalysis,
                    success: true
                };
                
            } catch (error) {
                console.error('AI işleme hatası:', error);
                return {
                    processedImage: null,
                    analysis: null,
                    success: false,
                    error: error.message
                };
            }
        }
        
        // Görüntü AI için optimizasyon
        async function optimizeImageForAI(imageFile) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Optimal boyutlandırma (768x768 AI işleme için)
                    const targetSize = 768;
                    let { width, height } = img;
                    
                    if (width > height) {
                        if (width > targetSize) {
                            height = (height * targetSize) / width;
                            width = targetSize;
                        }
                    } else {
                        if (height > targetSize) {
                            width = (width * targetSize) / height;
                            height = targetSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Yüksek kalite çizim
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    canvas.toBlob(resolve, 'image/png', 1.0);
                };
                
                img.onerror = reject;
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(imageFile);
                } else {
                    img.src = imageFile;
                }
            });
        }
        
        // Gelişmiş arka plan kaldırma (tüm algoritmaları birleştir)
        async function advancedBackgroundRemoval(imageFile) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // 1. Edge detection
                    const edges = detectEdges(data, canvas.width, canvas.height);
                    
                    // 2. Color clustering
                    const clusters = colorClustering(data, canvas.width, canvas.height, 6);
                    
                    // 3. Advanced foreground detection
                    const foregroundMask = detectForegroundAdvanced(data, canvas.width, canvas.height, edges, clusters);
                    
                    // 4. Morphological refinement
                    const refinedMask = refineMaskMorphologically(foregroundMask, canvas.width, canvas.height);
                    
                    // Alpha channel'ı güncelle
                    for (let i = 0; i < data.length; i += 4) {
                        const pixelIndex = Math.floor(i / 4);
                        data[i + 3] = refinedMask[pixelIndex] ? 255 : 0;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Canvas blob oluşturulamadı'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = reject;
                
                if (imageFile instanceof File || imageFile instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(imageFile);
                } else {
                    img.src = imageFile;
                }
            });
        }
        
        // Gelişmiş foreground detection
        function detectForegroundAdvanced(imageData, width, height, edges, clusters) {
            const mask = new Array(width * height).fill(false);
            const backgroundCluster = findBackgroundCluster(clusters, width, height);
            const centerRegion = getCenterRegion(width, height, 0.6);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const pixel = [imageData[pixelIdx], imageData[pixelIdx + 1], imageData[pixelIdx + 2]];
                    const clusterIdx = getPixelCluster(pixel, clusters);
                    
                    // Multi-criteria decision
                    let isForeground = false;
                    
                    // 1. Center region bias
                    if (centerRegion[idx]) {
                        isForeground = true;
                    }
                    
                    // 2. Not background cluster
                    if (clusterIdx !== backgroundCluster) {
                        isForeground = true;
                    }
                    
                    // 3. Strong edges
                    if (edges[idx] > 0.3) {
                        isForeground = true;
                    }
                    
                    // 4. Edge regions (likely background)
                    if (x < width * 0.1 || x > width * 0.9 || y < height * 0.1 || y > height * 0.9) {
                        if (clusterIdx === backgroundCluster) {
                            isForeground = false;
                        }
                    }
                    
                    mask[idx] = isForeground;
                }
            }
            
            return mask;
        }
        
        // Morphological mask refinement
        function refineMaskMorphologically(mask, width, height) {
            // Basit morphological operations
            let refined = [...mask];
            
            // Erosion (noise removal)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    if (mask[idx]) {
                        let neighborCount = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (mask[(y + dy) * width + (x + dx)]) {
                                    neighborCount++;
                                }
                            }
                        }
                        
                        // Keep pixel only if it has enough neighbors
                        refined[idx] = neighborCount >= 5;
                    }
                }
            }
            
            // Dilation (fill gaps)
            const dilated = [...refined];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    if (!refined[idx]) {
                        let hasNeighbor = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (refined[(y + dy) * width + (x + dx)]) {
                                    hasNeighbor = true;
                                    break;
                                }
                            }
                            if (hasNeighbor) break;
                        }
                        
                        dilated[idx] = hasNeighbor;
                    }
                }
            }
            
            return dilated;
        }

        // Görüntü analizi - Dominant renk, parlaklık, kontrast analizi
        async function analyzeImageProperties(imageUrl) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    const analysis = {
                        dominantColors: findDominantColors(data),
                        brightness: calculateBrightness(data),
                        contrast: calculateContrast(data),
                        colorHarmony: analyzeColorHarmony(data),
                        dimensions: { width: img.width, height: img.height },
                        aspectRatio: img.width / img.height
                    };
                    
                    resolve(analysis);
                };
                
                img.onerror = reject;
                img.src = imageUrl;
            });
        }
        
        // Dominant renkleri bulma
        function findDominantColors(imageData, numColors = 5) {
            const colorCounts = new Map();
            
            // Her 4. pikseli örnekle (performans için)
            for (let i = 0; i < imageData.length; i += 16) {
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                const a = imageData[i + 3];
                
                // Şeffaf pikselleri atla
                if (a < 128) continue;
                
                // Renkleri 16'lık gruplara böl (performans için)
                const key = `${Math.floor(r/16)*16},${Math.floor(g/16)*16},${Math.floor(b/16)*16}`;
                colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
            }
            
            // En yaygın renkleri sırala
            const sortedColors = Array.from(colorCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, numColors)
                .map(([color, count]) => {
                    const [r, g, b] = color.split(',').map(Number);
                    return {
                        rgb: [r, g, b],
                        hex: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`,
                        count: count,
                        percentage: (count / (imageData.length / 16)) * 100
                    };
                });
            
            return sortedColors;
        }
        
        // Parlaklık hesaplama
        function calculateBrightness(imageData) {
            let totalBrightness = 0;
            let pixelCount = 0;
            
            for (let i = 0; i < imageData.length; i += 4) {
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                const a = imageData[i + 3];
                
                // Şeffaf pikselleri atla
                if (a < 128) continue;
                
                // Luminance hesaplama (ITU-R BT.709)
                const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                totalBrightness += brightness;
                pixelCount++;
            }
            
            return pixelCount > 0 ? totalBrightness / pixelCount / 255 : 0;
        }
        
        // Kontrast hesaplama
        function calculateContrast(imageData) {
            const brightnesses = [];
            
            for (let i = 0; i < imageData.length; i += 4) {
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                const a = imageData[i + 3];
                
                // Şeffaf pikselleri atla
                if (a < 128) continue;
                
                const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                brightnesses.push(brightness);
            }
            
            if (brightnesses.length === 0) return 0;
            
            // Standart sapma hesaplama
            const mean = brightnesses.reduce((sum, b) => sum + b, 0) / brightnesses.length;
            const variance = brightnesses.reduce((sum, b) => sum + Math.pow(b - mean, 2), 0) / brightnesses.length;
            const standardDeviation = Math.sqrt(variance);
            
            // Normalize et (0-1 arası)
            return Math.min(standardDeviation / 128, 1);
        }
        
        // Renk harmonisi analizi
        function analyzeColorHarmony(imageData) {
            const dominantColors = findDominantColors(imageData, 3);
            
            if (dominantColors.length < 2) {
                return { harmony: 'monochromatic', score: 0.8 };
            }
            
            // HSV'ye çevir ve hue farklarını hesapla
            const hues = dominantColors.map(color => {
                const [r, g, b] = color.rgb.map(c => c / 255);
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let hue = 0;
                if (diff !== 0) {
                    if (max === r) {
                        hue = ((g - b) / diff) % 6;
                    } else if (max === g) {
                        hue = (b - r) / diff + 2;
                    } else {
                        hue = (r - g) / diff + 4;
                    }
                }
                
                return (hue * 60 + 360) % 360;
            });
            
            // Harmoni türünü belirle
            const hueDiffs = [];
            for (let i = 0; i < hues.length - 1; i++) {
                for (let j = i + 1; j < hues.length; j++) {
                    let diff = Math.abs(hues[i] - hues[j]);
                    if (diff > 180) diff = 360 - diff;
                    hueDiffs.push(diff);
                }
            }
            
            const avgDiff = hueDiffs.reduce((sum, diff) => sum + diff, 0) / hueDiffs.length;
            
            let harmony, score;
            if (avgDiff < 30) {
                harmony = 'analogous';
                score = 0.9;
            } else if (avgDiff > 150) {
                harmony = 'complementary';
                score = 0.85;
            } else if (avgDiff > 90 && avgDiff < 150) {
                harmony = 'triadic';
                score = 0.8;
            } else {
                harmony = 'mixed';
                score = 0.6;
            }
            
            return { harmony, score, averageHueDifference: avgDiff };
        }
        
        // Morphological operations uygulama
        async function applyMorphologicalOperations(imageUrl, analysis) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Analiz sonuçlarına göre morphological operations
                    let processedData;
                    if (analysis.contrast < 0.3) {
                        // Düşük kontrast - opening operation (noise removal)
                        processedData = morphologicalOpening(imageData);
                    } else if (analysis.contrast > 0.7) {
                        // Yüksek kontrast - closing operation (gap filling)
                        processedData = morphologicalClosing(imageData);
                    } else {
                        // Orta kontrast - hafif smoothing
                        processedData = morphologicalSmoothing(imageData);
                    }
                    
                    ctx.putImageData(processedData, 0, 0);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(URL.createObjectURL(blob));
                        } else {
                            reject(new Error('Morphological processing failed'));
                        }
                    }, 'image/png');
                };
                
                img.onerror = reject;
                img.src = imageUrl;
            });
        }
        
        // Morphological opening (erosion + dilation)
        function morphologicalOpening(imageData) {
            const eroded = morphologicalErosion(imageData);
            return morphologicalDilation(eroded);
        }
        
        // Morphological closing (dilation + erosion)
        function morphologicalClosing(imageData) {
            const dilated = morphologicalDilation(imageData);
            return morphologicalErosion(dilated);
        }
        
        // Morphological erosion
        function morphologicalErosion(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Alpha channel kontrolü
                    if (imageData.data[idx + 3] > 0) {
                        let minAlpha = 255;
                        
                        // 3x3 kernel
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                minAlpha = Math.min(minAlpha, imageData.data[nIdx + 3]);
                            }
                        }
                        
                        data[idx + 3] = minAlpha;
                    }
                }
            }
            
            return new ImageData(data, width, height);
        }
        
        // Morphological dilation
        function morphologicalDilation(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    let maxAlpha = 0;
                    
                    // 3x3 kernel
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            maxAlpha = Math.max(maxAlpha, imageData.data[nIdx + 3]);
                        }
                    }
                    
                    data[idx + 3] = maxAlpha;
                }
            }
            
            return new ImageData(data, width, height);
        }
        
        // Morphological smoothing
        function morphologicalSmoothing(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    let alphaSum = 0;
                    let count = 0;
                    
                    // 3x3 kernel
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            alphaSum += imageData.data[nIdx + 3];
                            count++;
                        }
                    }
                    
                    data[idx + 3] = Math.round(alphaSum / count);
                }
            }
            
            return new ImageData(data, width, height);
        }

        // Pozisyonlama Hesaplamaları - Golden ratio ve aspect ratio
        function calculateOptimalPositioning(foregroundDimensions, backgroundDimensions, analysis) {
            const { width: fgWidth, height: fgHeight } = foregroundDimensions;
            const { width: bgWidth, height: bgHeight } = backgroundDimensions;
            
            // Golden ratio pozisyonları
            const goldenRatio = 1.618;
            const goldenX = bgWidth / goldenRatio;
            const goldenY = bgHeight / goldenRatio;
            
            // Aspect ratio koruması
            const fgAspectRatio = fgWidth / fgHeight;
            const bgAspectRatio = bgWidth / bgHeight;
            
            let optimalWidth, optimalHeight;
            
            // Foreground boyutunu optimize et
            if (fgAspectRatio > bgAspectRatio) {
                // Landscape foreground
                optimalWidth = Math.min(fgWidth, bgWidth * 0.7);
                optimalHeight = optimalWidth / fgAspectRatio;
            } else {
                // Portrait foreground
                optimalHeight = Math.min(fgHeight, bgHeight * 0.8);
                optimalWidth = optimalHeight * fgAspectRatio;
            }
            
            // Dominant renklere göre pozisyon ayarla
            let positionX = goldenX - (optimalWidth / 2);
            let positionY = goldenY - (optimalHeight / 2);
            
            // Parlaklık analizi ile pozisyon fine-tuning
            if (analysis.brightness > 0.7) {
                // Parlak görüntü - biraz daha merkeze
                positionX += (bgWidth / 2 - goldenX) * 0.3;
                positionY += (bgHeight / 2 - goldenY) * 0.3;
            } else if (analysis.brightness < 0.3) {
                // Karanlık görüntü - golden ratio'ya daha yakın
                positionX += (goldenX - bgWidth / 2) * 0.2;
                positionY += (goldenY - bgHeight / 2) * 0.2;
            }
            
            // Sınırları kontrol et
            positionX = Math.max(0, Math.min(positionX, bgWidth - optimalWidth));
            positionY = Math.max(0, Math.min(positionY, bgHeight - optimalHeight));
            
            return {
                x: Math.round(positionX),
                y: Math.round(positionY),
                width: Math.round(optimalWidth),
                height: Math.round(optimalHeight),
                scale: optimalWidth / fgWidth,
                goldenRatioUsed: true
            };
        }
        
        // Işık yönü analizi
        function analyzeLightDirection(imageData, width, height) {
            const sectors = {
                topLeft: { sum: 0, count: 0 },
                topRight: { sum: 0, count: 0 },
                bottomLeft: { sum: 0, count: 0 },
                bottomRight: { sum: 0, count: 0 }
            };
            
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = imageData[idx];
                    const g = imageData[idx + 1];
                    const b = imageData[idx + 2];
                    const a = imageData[idx + 3];
                    
                    if (a < 128) continue;
                    
                    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    if (x < halfWidth && y < halfHeight) {
                        sectors.topLeft.sum += brightness;
                        sectors.topLeft.count++;
                    } else if (x >= halfWidth && y < halfHeight) {
                        sectors.topRight.sum += brightness;
                        sectors.topRight.count++;
                    } else if (x < halfWidth && y >= halfHeight) {
                        sectors.bottomLeft.sum += brightness;
                        sectors.bottomLeft.count++;
                    } else {
                        sectors.bottomRight.sum += brightness;
                        sectors.bottomRight.count++;
                    }
                }
            }
            
            // Her sektörün ortalama parlaklığını hesapla
            const averages = {};
            for (const [sector, data] of Object.entries(sectors)) {
                averages[sector] = data.count > 0 ? data.sum / data.count : 0;
            }
            
            // En parlak sektörü bul (ışık kaynağı)
            const brightestSector = Object.entries(averages)
                .reduce((max, [sector, brightness]) => 
                    brightness > max.brightness ? { sector, brightness } : max, 
                    { sector: 'topLeft', brightness: 0 }
                );
            
            // Işık yönünü belirle
            const lightDirections = {
                topLeft: { x: -0.7, y: -0.7, angle: 225 },
                topRight: { x: 0.7, y: -0.7, angle: 315 },
                bottomLeft: { x: -0.7, y: 0.7, angle: 135 },
                bottomRight: { x: 0.7, y: 0.7, angle: 45 }
            };
            
            return {
                direction: lightDirections[brightestSector.sector],
                intensity: brightestSector.brightness / 255,
                sector: brightestSector.sector
            };
        }
        
        // Gerçekçi gölge oluşturma
        function createRealisticShadow(canvas, ctx, positioning, lightAnalysis, analysis) {
            const shadowCanvas = document.createElement('canvas');
            const shadowCtx = shadowCanvas.getContext('2d');
            
            shadowCanvas.width = canvas.width;
            shadowCanvas.height = canvas.height;
            
            // Gölge parametreleri
            const shadowIntensity = Math.max(0.2, 1 - lightAnalysis.intensity);
            const shadowBlur = Math.max(5, positioning.width * 0.02);
            const shadowDistance = Math.max(3, positioning.width * 0.01);
            
            // Işık yönüne göre gölge offset
            const shadowOffsetX = -lightAnalysis.direction.x * shadowDistance;
            const shadowOffsetY = -lightAnalysis.direction.y * shadowDistance;
            
            // Gölge rengi (dominant renklere göre)
            let shadowColor = 'rgba(0, 0, 0, 0.3)';
            if (analysis.dominantColors && analysis.dominantColors.length > 0) {
                const dominantColor = analysis.dominantColors[0].rgb;
                const darkerColor = dominantColor.map(c => Math.max(0, c - 50));
                shadowColor = `rgba(${darkerColor[0]}, ${darkerColor[1]}, ${darkerColor[2]}, ${shadowIntensity * 0.4})`;
            }
            
            // Gölge çiz
            shadowCtx.save();
            
            // Blur efekti
            shadowCtx.filter = `blur(${shadowBlur}px)`;
            
            // Gölge şekli (eliptik)
            shadowCtx.fillStyle = shadowColor;
            shadowCtx.beginPath();
            
            const shadowX = positioning.x + shadowOffsetX;
            const shadowY = positioning.y + positioning.height - shadowDistance;
            const shadowWidth = positioning.width * 0.8;
            const shadowHeight = positioning.height * 0.2;
            
            shadowCtx.ellipse(
                shadowX + shadowWidth / 2,
                shadowY + shadowHeight / 2,
                shadowWidth / 2,
                shadowHeight / 2,
                0, 0, 2 * Math.PI
            );
            
            shadowCtx.fill();
            shadowCtx.restore();
            
            // Ana canvas'a gölgeyi ekle
            ctx.globalCompositeOperation = 'multiply';
            ctx.globalAlpha = shadowIntensity;
            ctx.drawImage(shadowCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            
            return {
                offsetX: shadowOffsetX,
                offsetY: shadowOffsetY,
                blur: shadowBlur,
                intensity: shadowIntensity,
                color: shadowColor
            };
        }
        
        // Gelişmiş kompozisyon fonksiyonunu güncelle
        async function combineImagesWithAdvancedPositioning(foregroundFile, backgroundFile) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Görüntüleri analiz et
                    const foregroundUrl = URL.createObjectURL(foregroundFile);
                    const backgroundUrl = URL.createObjectURL(backgroundFile);
                    
                    const [fgAnalysis, bgAnalysis] = await Promise.all([
                        analyzeImageProperties(foregroundUrl),
                        analyzeImageProperties(backgroundUrl)
                    ]);
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Background yükle
                    const bgImg = new Image();
                    bgImg.onload = function() {
                        canvas.width = 1024;
                        canvas.height = 1024;
                        
                        // Background çiz (1024x1024'e scale)
                        ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                        
                        // Foreground yükle
                        const fgImg = new Image();
                        fgImg.onload = function() {
                            // Optimal pozisyonlama hesapla
                            const positioning = calculateOptimalPositioning(
                                { width: fgImg.width, height: fgImg.height },
                                { width: canvas.width, height: canvas.height },
                                fgAnalysis
                            );
                            
                            // Işık analizi
                            const fgCanvas = document.createElement('canvas');
                            const fgCtx = fgCanvas.getContext('2d');
                            fgCanvas.width = fgImg.width;
                            fgCanvas.height = fgImg.height;
                            fgCtx.drawImage(fgImg, 0, 0);
                            
                            const fgImageData = fgCtx.getImageData(0, 0, fgCanvas.width, fgCanvas.height);
                            const lightAnalysis = analyzeLightDirection(fgImageData.data, fgCanvas.width, fgCanvas.height);
                            
                            // Gölge oluştur
                            const shadowInfo = createRealisticShadow(canvas, ctx, positioning, lightAnalysis, fgAnalysis);
                            
                            // Foreground'u çiz
                            ctx.drawImage(
                                fgImg,
                                positioning.x,
                                positioning.y,
                                positioning.width,
                                positioning.height
                            );
                            
                            // Final efektler
                            applyFinalCompositionEffects(ctx, canvas, fgAnalysis, bgAnalysis);
                            
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve({
                                        url: URL.createObjectURL(blob),
                                        positioning: positioning,
                                        lightAnalysis: lightAnalysis,
                                        shadowInfo: shadowInfo,
                                        analysis: { foreground: fgAnalysis, background: bgAnalysis }
                                    });
                                } else {
                                    reject(new Error('Canvas blob oluşturulamadı'));
                                }
                            }, 'image/png');
                        };
                        
                        fgImg.onerror = reject;
                        fgImg.src = foregroundUrl;
                    };
                    
                    bgImg.onerror = reject;
                    bgImg.src = backgroundUrl;
                    
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Final kompozisyon efektleri
        function applyFinalCompositionEffects(ctx, canvas, fgAnalysis, bgAnalysis) {
            // Renk harmonisi düzeltmesi
            if (fgAnalysis.colorHarmony.score < 0.7) {
                adjustColorHarmony(ctx, canvas, fgAnalysis, bgAnalysis);
            }
            
            // Kontrast dengeleme
            if (Math.abs(fgAnalysis.contrast - bgAnalysis.contrast) > 0.3) {
                balanceContrast(ctx, canvas, fgAnalysis, bgAnalysis);
            }
            
            // Hafif vignette efekti
            applySubtleVignette(ctx, canvas);
        }
        
        // Renk harmonisi düzeltmesi
        function adjustColorHarmony(ctx, canvas, fgAnalysis, bgAnalysis) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Basit renk sıcaklığı ayarı
            const fgTemp = calculateColorTemperature(fgAnalysis.dominantColors);
            const bgTemp = calculateColorTemperature(bgAnalysis.dominantColors);
            
            if (Math.abs(fgTemp - bgTemp) > 0.2) {
                const adjustment = (bgTemp - fgTemp) * 0.3;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (adjustment > 0) {
                        // Daha sıcak
                        data[i] = Math.min(255, data[i] + adjustment * 20);
                        data[i + 2] = Math.max(0, data[i + 2] - adjustment * 10);
                    } else {
                        // Daha soğuk
                        data[i] = Math.max(0, data[i] + adjustment * 20);
                        data[i + 2] = Math.min(255, data[i + 2] - adjustment * 10);
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Renk sıcaklığı hesaplama
        function calculateColorTemperature(dominantColors) {
            if (!dominantColors || dominantColors.length === 0) return 0.5;
            
            let totalTemp = 0;
            let totalWeight = 0;
            
            dominantColors.forEach(color => {
                const [r, g, b] = color.rgb;
                const temp = (r - b) / 255; // Basit sıcaklık hesabı
                totalTemp += temp * color.percentage;
                totalWeight += color.percentage;
            });
            
            return totalWeight > 0 ? (totalTemp / totalWeight + 1) / 2 : 0.5;
        }
        
        // Kontrast dengeleme
        function balanceContrast(ctx, canvas, fgAnalysis, bgAnalysis) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const contrastDiff = bgAnalysis.contrast - fgAnalysis.contrast;
            const adjustment = contrastDiff * 0.5;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Kontrast ayarı
                const factor = 1 + adjustment;
                data[i] = Math.max(0, Math.min(255, ((r - 128) * factor) + 128));
                data[i + 1] = Math.max(0, Math.min(255, ((g - 128) * factor) + 128));
                data[i + 2] = Math.max(0, Math.min(255, ((b - 128) * factor) + 128));
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Hafif vignette efekti
        function applySubtleVignette(ctx, canvas) {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
            );
            
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
            
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        // Final Optimizasyonlar - Gelişmiş blur efektleri ve kalite iyileştirmeleri
        
        // Adaptif blur efekti
        function applyAdaptiveBlur(ctx, canvas, analysis) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Kontrast analizi ile blur seviyesi belirleme
            const blurIntensity = analysis.contrast > 0.7 ? 0.5 : (analysis.contrast < 0.3 ? 1.5 : 1.0);
            
            // Gaussian blur kernel
            const kernel = generateGaussianKernel(Math.round(blurIntensity * 3));
            const kernelSize = kernel.length;
            const halfKernel = Math.floor(kernelSize / 2);
            
            const newData = new Uint8ClampedArray(data.length);
            
            for (let y = halfKernel; y < height - halfKernel; y++) {
                for (let x = halfKernel; x < width - halfKernel; x++) {
                    const idx = (y * width + x) * 4;
                    
                    let r = 0, g = 0, b = 0, a = 0;
                    let totalWeight = 0;
                    
                    for (let ky = 0; ky < kernelSize; ky++) {
                        for (let kx = 0; kx < kernelSize; kx++) {
                            const py = y + ky - halfKernel;
                            const px = x + kx - halfKernel;
                            const pidx = (py * width + px) * 4;
                            const weight = kernel[ky][kx];
                            
                            r += data[pidx] * weight;
                            g += data[pidx + 1] * weight;
                            b += data[pidx + 2] * weight;
                            a += data[pidx + 3] * weight;
                            totalWeight += weight;
                        }
                    }
                    
                    newData[idx] = Math.round(r / totalWeight);
                    newData[idx + 1] = Math.round(g / totalWeight);
                    newData[idx + 2] = Math.round(b / totalWeight);
                    newData[idx + 3] = Math.round(a / totalWeight);
                }
            }
            
            // Kenar pikselleri kopyala
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (y < halfKernel || y >= height - halfKernel || x < halfKernel || x >= width - halfKernel) {
                        const idx = (y * width + x) * 4;
                        newData[idx] = data[idx];
                        newData[idx + 1] = data[idx + 1];
                        newData[idx + 2] = data[idx + 2];
                        newData[idx + 3] = data[idx + 3];
                    }
                }
            }
            
            const newImageData = new ImageData(newData, width, height);
            ctx.putImageData(newImageData, 0, 0);
        }
        
        // Gaussian kernel oluşturma
        function generateGaussianKernel(size) {
            const kernel = [];
            const sigma = size / 3;
            const twoSigmaSquare = 2 * sigma * sigma;
            let sum = 0;
            
            for (let y = 0; y < size; y++) {
                kernel[y] = [];
                for (let x = 0; x < size; x++) {
                    const distance = Math.pow(x - Math.floor(size / 2), 2) + Math.pow(y - Math.floor(size / 2), 2);
                    const value = Math.exp(-distance / twoSigmaSquare);
                    kernel[y][x] = value;
                    sum += value;
                }
            }
            
            // Normalize
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }
            
            return kernel;
        }
        
        // Gelişmiş renk düzeltmesi
        function enhanceColorQuality(ctx, canvas, fgAnalysis, bgAnalysis) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Renk doygunluğu ayarı
            const saturationBoost = calculateSaturationBoost(fgAnalysis, bgAnalysis);
            
            // Gamma düzeltmesi
            const gamma = calculateOptimalGamma(fgAnalysis, bgAnalysis);
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                
                // RGB'yi HSL'ye çevir
                const hsl = rgbToHsl(r, g, b);
                
                // Doygunluğu artır
                hsl[1] = Math.min(1, hsl[1] * saturationBoost);
                
                // HSL'yi RGB'ye geri çevir
                const rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
                
                // Gamma düzeltmesi uygula
                data[i] = Math.round(Math.pow(rgb[0], 1 / gamma) * 255);
                data[i + 1] = Math.round(Math.pow(rgb[1], 1 / gamma) * 255);
                data[i + 2] = Math.round(Math.pow(rgb[2], 1 / gamma) * 255);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Doygunluk artırma hesaplama
        function calculateSaturationBoost(fgAnalysis, bgAnalysis) {
            const avgSaturation = (calculateAverageSaturation(fgAnalysis.dominantColors) + 
                                 calculateAverageSaturation(bgAnalysis.dominantColors)) / 2;
            
            if (avgSaturation < 0.3) {
                return 1.3; // Düşük doygunluk - artır
            } else if (avgSaturation > 0.8) {
                return 0.9; // Yüksek doygunluk - azalt
            }
            
            return 1.1; // Orta doygunluk - hafif artır
        }
        
        // Ortalama doygunluk hesaplama
        function calculateAverageSaturation(dominantColors) {
            if (!dominantColors || dominantColors.length === 0) return 0.5;
            
            let totalSaturation = 0;
            let totalWeight = 0;
            
            dominantColors.forEach(color => {
                const [r, g, b] = color.rgb.map(c => c / 255);
                const hsl = rgbToHsl(r, g, b);
                totalSaturation += hsl[1] * color.percentage;
                totalWeight += color.percentage;
            });
            
            return totalWeight > 0 ? totalSaturation / totalWeight : 0.5;
        }
        
        // Optimal gamma hesaplama
        function calculateOptimalGamma(fgAnalysis, bgAnalysis) {
            const avgBrightness = (fgAnalysis.brightness + bgAnalysis.brightness) / 2;
            
            if (avgBrightness < 0.3) {
                return 0.8; // Karanlık görüntü - aydınlat
            } else if (avgBrightness > 0.7) {
                return 1.2; // Parlak görüntü - koyulaştır
            }
            
            return 1.0; // Normal
        }
        
        // RGB'den HSL'ye çevirme
        function rgbToHsl(r, g, b) {
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Gri
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        // HSL'den RGB'ye çevirme
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // Gri
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [r, g, b];
        }
        
        // Kenar yumuşatma
        function applySoftEdges(ctx, canvas) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Alpha channel'da kenar yumuşatma
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const currentAlpha = data[idx + 3];
                    
                    if (currentAlpha > 0 && currentAlpha < 255) {
                        // Kenar pikseli - yumuşat
                        let alphaSum = 0;
                        let count = 0;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                alphaSum += data[nIdx + 3];
                                count++;
                            }
                        }
                        
                        const avgAlpha = alphaSum / count;
                        data[idx + 3] = Math.round((currentAlpha + avgAlpha) / 2);
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Master optimizasyon fonksiyonu
        async function applyFinalOptimizations(canvas, ctx, fgAnalysis, bgAnalysis) {
            // 1. Renk kalitesi iyileştirme
            enhanceColorQuality(ctx, canvas, fgAnalysis, bgAnalysis);
            
            // 2. Adaptif blur (hafif)
            applyAdaptiveBlur(ctx, canvas, fgAnalysis);
            
            // 3. Kenar yumuşatma
            applySoftEdges(ctx, canvas);
            
            // 4. Final vignette (daha hafif)
            applySubtleVignette(ctx, canvas);
            
            return {
                colorEnhanced: true,
                blurApplied: true,
                edgesSoftened: true,
                vignetteApplied: true
            };
        }
        
        // Ana AI işleme fonksiyonunu güncelle
        async function processImageWithFullAI(imageFile) {
            try {
                console.log('🚀 Gelişmiş AI görüntü işleme başlatılıyor...');
                
                // 1. Görüntü optimizasyonu
                const optimizedImage = await optimizeImageForAI(imageFile);
                console.log('✅ Görüntü optimizasyonu tamamlandı');
                
                // 2. Gelişmiş arka plan kaldırma
                const backgroundRemoved = await advancedBackgroundRemoval(optimizedImage);
                console.log('✅ Gelişmiş arka plan kaldırma tamamlandı');
                
                // 3. Görüntü analizi
                const imageAnalysis = await analyzeImageProperties(backgroundRemoved);
                console.log('✅ Görüntü analizi tamamlandı:', imageAnalysis);
                
                // 4. Morphological operations
                const morphProcessed = await applyMorphologicalOperations(backgroundRemoved, imageAnalysis);
                console.log('✅ Morphological operations tamamlandı');
                
                // 5. Final optimizasyonlar
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve, reject) => {
                    img.onload = async function() {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        const optimizationResults = await applyFinalOptimizations(canvas, ctx, imageAnalysis, imageAnalysis);
                        console.log('✅ Final optimizasyonlar tamamlandı:', optimizationResults);
                        
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve({
                                    processedImage: URL.createObjectURL(blob),
                                    analysis: imageAnalysis,
                                    optimizations: optimizationResults,
                                    success: true
                                });
                            } else {
                                reject(new Error('Final canvas blob oluşturulamadı'));
                            }
                        }, 'image/png');
                    };
                    
                    img.onerror = reject;
                    img.src = morphProcessed;
                });
                
            } catch (error) {
                console.error('❌ AI işleme hatası:', error);
                return {
                    processedImage: null,
                    analysis: null,
                    optimizations: null,
                    success: false,
                    error: error.message
                };
            }
        }

        async function removeBackground(imageFile) {
            // Deprecated - use removeBackgroundWithRetry instead
            return await removeBackgroundWithRetry(imageFile);
        }
        
        // Gelişmiş API Client Sistemi
        class SmartAPIClient {
            constructor(config) {
                this.config = config;
                this.cache = new Map();
                this.metrics = {
                    requests: 0,
                    successes: 0,
                    failures: 0,
                    averageResponseTime: 0
                };
            }
            
            async processBackgroundRemoval(imageFile, options = {}) {
                const startTime = Date.now();
                
                try {
                    // Primary servislerden dene
                    const primaryServices = [
                        { name: 'huggingface', enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN') },
                        { name: 'photoscissors', enabled: () => true },
                        { name: 'removebg', enabled: () => !!getEnvVariable('REMOVEBG_TOKEN') },
                        { name: 'replicate', enabled: () => !!getEnvVariable('REPLICATE_TOKEN') }
                    ];
                    
                    for (const service of primaryServices) {
                        if (!service.enabled()) continue;
                        
                        try {
                            updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan kaldırılıyor...`);
                            
                            const result = await removeBackgroundWithProvider(imageFile, service.name);
                            
                            if (result) {
                                this.recordSuccess(Date.now() - startTime);
                                return result;
                            }
                            
                        } catch (error) {
                            console.error(`${service.name} failed:`, error);
                            this.recordFailure();
                        }
                    }
                    
                    throw new Error('Tüm arka plan kaldırma servisleri başarısız oldu');
                    
                } catch (error) {
                    this.recordFailure();
                    throw error;
                }
            }
            
            async processImageGeneration(prompt, options = {}) {
                const startTime = Date.now();
                
                try {
                    // Primary servislerden dene
                    const primaryServices = [
                        { name: 'huggingface', enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN') },
                        { name: 'pollinations', enabled: () => true },
                        { name: 'replicate', enabled: () => !!getEnvVariable('REPLICATE_TOKEN') }
                    ];
                    
                    for (const service of primaryServices) {
                        if (!service.enabled()) continue;
                        
                        try {
                            updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan oluşturuluyor...`);
                            
                            const result = await generateBackgroundWithProvider(prompt, service.name);
                            
                            if (result) {
                                this.recordSuccess(Date.now() - startTime);
                                return result;
                            }
                            
                        } catch (error) {
                            console.error(`${service.name} failed:`, error);
                            this.recordFailure();
                        }
                    }
                    
                    throw new Error('Tüm görüntü oluşturma servisleri başarısız oldu');
                    
                } catch (error) {
                    this.recordFailure();
                    throw error;
                }
            }
            
            recordSuccess(responseTime) {
                this.metrics.requests++;
                this.metrics.successes++;
                this.metrics.averageResponseTime = 
                    (this.metrics.averageResponseTime * (this.metrics.requests - 1) + responseTime) / this.metrics.requests;
            }
            
            recordFailure() {
                this.metrics.requests++;
                this.metrics.failures++;
            }
            
            getMetrics() {
                return {
                    ...this.metrics,
                    successRate: this.metrics.requests > 0 ? (this.metrics.successes / this.metrics.requests) * 100 : 0
                };
            }
        }
        
        // Global API client instance
        const apiClient = new SmartAPIClient(API_CONFIG);

        // Removed local processing functions - API only approach

        async function generateBackgroundWithRetry(prompt, maxRetries = 5) {
            // En güçlü ücretsiz modeli önceliklendir: Hugging Face SDXL
            const providers = ['huggingface', 'pollinations', 'replicate'];
            
            for (const provider of providers) {
                if (!API_CONFIG.providers[provider].enabled) continue;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        updateLoadingMessage(`${provider.toUpperCase()} ile arka plan oluşturuluyor... (${attempt}/${maxRetries})`);
                        
                        const result = await generateBackgroundWithProvider(prompt, provider);
                        if (result) return result;
                        
                    } catch (error) {
                        console.error(`${provider} attempt ${attempt} failed:`, error);
                        
                        if (attempt < maxRetries) {
                            const delay = API_CONFIG.retryDelay * attempt;
                            updateLoadingMessage(`${delay/1000} saniye bekleniyor...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
            }
            
            throw new Error('Tüm görüntü oluşturma servisleri başarısız oldu. Lütfen daha sonra tekrar deneyin.');
        }

        async function generateBackgroundWithProvider(prompt, provider) {
            const config = API_CONFIG.providers[provider];
            
            switch (provider) {
                case 'huggingface':
                    return await generateBackgroundHuggingFace(prompt, config);
                case 'pollinations':
                    return await generateBackgroundPollinations(prompt);
                case 'replicate':
                    return await generateBackgroundReplicate(prompt, config);
                default:
                    throw new Error(`Bilinmeyen provider: ${provider}`);
            }
        }

        async function generateBackgroundHuggingFace(prompt, config) {
            const API_URL = `${config.baseUrl}${config.imageGenerationModel}`;
            
            const enhancedPrompt = enhancePromptForQuality(prompt);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(API_URL, {
                    headers: {
                        "Authorization": `Bearer ${config.token}`,
                        "Content-Type": "application/json",
                    },
                    method: "POST",
                    body: JSON.stringify({
                        "inputs": enhancedPrompt,
                        "parameters": {
                            "num_inference_steps": 30,
                            "guidance_scale": 8.5,
                            "width": API_CONFIG.imageQuality.maxWidth,
                            "height": API_CONFIG.imageQuality.maxHeight,
                            "negative_prompt": "blurry, low quality, distorted, ugly, bad anatomy, extra limbs, watermark, text, signature"
                        }
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Hugging Face generation error: ${response.status} - ${errorText}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        async function generateBackgroundPollinations(prompt) {
            const enhancedPrompt = enhancePromptForQuality(prompt);
            const encodedPrompt = encodeURIComponent(enhancedPrompt);
            const imageUrl = `${API_CONFIG.providers.pollinations.baseUrl}${encodedPrompt}?width=${API_CONFIG.imageQuality.maxWidth}&height=${API_CONFIG.imageQuality.maxHeight}&seed=${Math.floor(Math.random() * 1000000)}`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);
            
            try {
                const response = await fetch(imageUrl, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Pollinations API error: ${response.status}`);
                }
                
                const blob = await response.blob();
                return URL.createObjectURL(blob);
                
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        function enhancePromptForQuality(prompt) {
            const qualityEnhancements = [
                "professional photography",
                "high resolution",
                "detailed",
                "masterpiece",
                "best quality",
                "ultra detailed",
                "8k uhd",
                "realistic",
                "photorealistic",
                "cinematic lighting",
                "sharp focus",
                "vivid colors"
            ];
            
            return `${prompt}, ${qualityEnhancements.join(', ')}`;
        }

        async function generateBackground(prompt) {
            // Deprecated - use generateBackgroundWithRetry instead
            return await generateBackgroundWithRetry(prompt);
        }

        async function combineImagesAdvanced(foreground, background) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Yüksek kalite için 1024x1024 boyut
                canvas.width = 1024;
                canvas.height = 1024;
                
                const bgImg = new Image();
                const fgImg = new Image();
                
                let loadedImages = 0;
                
                const onImageLoad = () => {
                    loadedImages++;
                    if (loadedImages === 2) {
                        // Gelişmiş kompozisyon algoritması
                        performAdvancedComposition(ctx, fgImg, bgImg, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.95));
                    }
                };
                
                bgImg.onload = onImageLoad;
                fgImg.onload = onImageLoad;
                
                bgImg.src = background;
                fgImg.src = foreground;
            });
        }
        
        // Gelişmiş kompozisyon algoritması
        function performAdvancedComposition(ctx, fgImg, bgImg, canvasWidth, canvasHeight) {
            // 1. Background'u depth of field ile çiz
            drawBackgroundWithDepthOfField(ctx, bgImg, canvasWidth, canvasHeight);
            
            // 2. Foreground analizi
            const fgAnalysis = analyzeForegroundImage(fgImg);
            
            // 3. Lighting analizi
            const lightingInfo = analyzeLighting(bgImg);
            
            // 4. Golden ratio pozisyonlama
            const position = calculateGoldenRatioPosition(canvasWidth, canvasHeight, fgImg.width, fgImg.height);
            
            // 5. Foreground'u ayarla ve çiz
            drawAdjustedForeground(ctx, fgImg, position, lightingInfo);
            
            // 6. Gerçekçi gölge ekle
            addRealisticShadow(ctx, position, lightingInfo);
            
            // 7. Final efektler
            applyFinalEffects(ctx, canvasWidth, canvasHeight);
        }
        
        // Background'u depth of field ile çiz
        function drawBackgroundWithDepthOfField(ctx, bgImg, width, height) {
            // Background'u çiz
            ctx.drawImage(bgImg, 0, 0, width, height);
            
            // Hafif blur efekti için composite operation
            ctx.globalCompositeOperation = 'multiply';
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
        }
        
        // Foreground görüntü analizi
        function analyzeForegroundImage(fgImg) {
            return {
                aspectRatio: fgImg.width / fgImg.height,
                dominantColor: [128, 128, 128], // Basit yaklaşım
                brightness: 0.5,
                contrast: 0.5
            };
        }
        
        // Lighting analizi
        function analyzeLighting(bgImg) {
            return {
                direction: { x: 0.3, y: -0.7 }, // Sol üstten gelen ışık
                intensity: 0.8,
                color: [255, 248, 220] // Warm light
            };
        }
        
        // Golden ratio pozisyonlama
        function calculateGoldenRatioPosition(canvasWidth, canvasHeight, fgWidth, fgHeight) {
            const goldenRatio = 1.618;
            
            // Foreground boyutunu hesapla
            let scaledWidth, scaledHeight;
            const maxScale = 0.6; // Canvas'ın %60'ı kadar
            
            if (fgWidth > fgHeight) {
                scaledWidth = canvasWidth * maxScale;
                scaledHeight = scaledWidth * (fgHeight / fgWidth);
            } else {
                scaledHeight = canvasHeight * maxScale;
                scaledWidth = scaledHeight * (fgWidth / fgHeight);
            }
            
            // Golden ratio ile pozisyon hesapla
            const x = canvasWidth / goldenRatio - scaledWidth / 2;
            const y = canvasHeight - scaledHeight - (canvasHeight / goldenRatio / 2);
            
            return {
                x: Math.max(0, Math.min(x, canvasWidth - scaledWidth)),
                y: Math.max(0, Math.min(y, canvasHeight - scaledHeight)),
                width: scaledWidth,
                height: scaledHeight
            };
        }
        
        // Ayarlanmış foreground çizimi
        function drawAdjustedForeground(ctx, fgImg, position, lightingInfo) {
            ctx.save();
            
            // Color adjustment için composite operation
            ctx.globalCompositeOperation = 'source-over';
            
            // Foreground'u çiz
            ctx.drawImage(fgImg, position.x, position.y, position.width, position.height);
            
            // Lighting adjustment
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.1;
            
            const gradient = ctx.createLinearGradient(
                position.x, position.y,
                position.x + position.width * lightingInfo.direction.x,
                position.y + position.height * lightingInfo.direction.y
            );
            
            gradient.addColorStop(0, `rgb(${lightingInfo.color.join(',')})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(position.x, position.y, position.width, position.height);
            
            ctx.restore();
        }
        
        // Gerçekçi gölge ekleme
        function addRealisticShadow(ctx, position, lightingInfo) {
            ctx.save();
            
            // Gölge parametreleri
            const shadowOffset = {
                x: -lightingInfo.direction.x * 20,
                y: Math.abs(lightingInfo.direction.y) * 15
            };
            
            const shadowX = position.x + shadowOffset.x;
            const shadowY = position.y + position.height + shadowOffset.y;
            
            // Gölge gradyanı
            const shadowGradient = ctx.createRadialGradient(
                shadowX + position.width / 2, shadowY,
                0,
                shadowX + position.width / 2, shadowY,
                position.width / 2
            );
            
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadowGradient;
            
            // Eliptik gölge
            ctx.beginPath();
            ctx.ellipse(
                shadowX + position.width / 2, shadowY,
                position.width / 3, position.width / 6,
                0, 0, 2 * Math.PI
            );
            ctx.fill();
            
            ctx.restore();
        }
        
        // Final efektler
        function applyFinalEffects(ctx, width, height) {
            // Subtle vignette
            const vignette = ctx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, width / 2
            );
            
            vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
            vignette.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
            
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, width, height);
            
            // Color harmony adjustment
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#f4e4bc'; // Warm tone
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
        }

        // Removed local processing functions - API only approach

        function showDemoResult() {
            // Demo sonuç gösterimi
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('previewSection').style.display = 'block';
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 400;
            
            // Lokasyona göre arka plan
            const gradient = ctx.createLinearGradient(0, 0, 400, 400);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(1, '#4ecdc4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 400, 400);
            
            // Lokasyon bilgisi
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(selectedLocation.emoji, 200, 150);
            ctx.fillText(selectedLocation.name, 200, 200);
            ctx.font = '16px Arial';
            ctx.fillText('AI ile düzenlenmiş fotoğraf', 200, 240);
            ctx.fillText(`${parameters.time} • ${parameters.weather}`, 200, 260);
            
            document.getElementById('previewImage').src = canvas.toDataURL();
            document.getElementById('shareBtn').style.display = 'inline-block';
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `ai-photo-${selectedLocation.name.toLowerCase()}.jpg`;
            link.href = document.getElementById('previewImage').src;
            link.click();
        }

        function resetApp() {
            selectedPhoto = null;
            selectedCategory = null;
            selectedLocation = null;
            parameters = {
                time: 'morning',
                weather: 'sunny',
                crowd: 30,
                quality: 8
            };
            
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('fileInput').value = '';
            document.getElementById('shareBtn').style.display = 'none';
        }

        // Social Sharing Function
        async function shareImage() {
            const previewImage = document.getElementById('previewImage');
            
            if (!previewImage.src) {
                alert('Paylaşılacak fotoğraf bulunamadı!');
                return;
            }

            try {
                // Web Share API desteği kontrolü
                if (navigator.share && navigator.canShare) {
                    // Canvas'tan blob oluştur
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = async function() {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob(async (blob) => {
                            const file = new File([blob], 'ai-travel-photo.jpg', { type: 'image/jpeg' });
                            
                            const shareData = {
                                title: 'AI Photo Travel ile Oluşturuldu',
                                text: 'Hayal ettiğim yerde çekilmiş fotoğrafım! 🌍✈️ #AIPhotoTravel',
                                files: [file]
                            };

                            if (navigator.canShare(shareData)) {
                                try {
                                    await navigator.share(shareData);
                                    console.log('Fotoğraf başarıyla paylaşıldı');
                                } catch (err) {
                                    console.log('Paylaşım iptal edildi:', err);
                                    fallbackShare();
                                }
                            } else {
                                fallbackShare();
                            }
                        }, 'image/jpeg', 0.9);
                    };
                    
                    img.src = previewImage.src;
                } else {
                    fallbackShare();
                }
            } catch (error) {
                console.error('Paylaşım hatası:', error);
                fallbackShare();
            }
        }

        function fallbackShare() {
            // Fallback: Kopyalama ve sosyal medya linkleri
            const shareText = 'AI Photo Travel ile hayal ettiğim yerde çekilmiş fotoğrafım! 🌍✈️';
            const shareUrl = window.location.href;
            
            // Clipboard API ile metni kopyala
            if (navigator.clipboard) {
                navigator.clipboard.writeText(`${shareText} ${shareUrl}`).then(() => {
                    showShareOptions();
                });
            } else {
                showShareOptions();
            }
        }

        function showShareOptions() {
            const shareModal = document.createElement('div');
            shareModal.className = 'modal';
            shareModal.style.display = 'block';
            shareModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <button class="close-btn" onclick="this.parentElement.parentElement.remove()">×</button>
                    <div class="modal-header">
                        <div class="modal-title">📤 Fotoğrafını Paylaş</div>
                        <div class="modal-subtitle">Sosyal medyada arkadaşlarınla paylaş</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
                        <button onclick="shareToWhatsApp()" style="background: #25D366; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            📱 WhatsApp
                        </button>
                        <button onclick="shareToTwitter()" style="background: #1DA1F2; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            🐦 Twitter
                        </button>
                        <button onclick="shareToFacebook()" style="background: #4267B2; color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            📘 Facebook
                        </button>
                        <button onclick="shareToInstagram()" style="background: linear-gradient(45deg, #f09433 0%,#e6683c 25%,#dc2743 50%,#cc2366 75%,#bc1888 100%); color: white; border: none; padding: 15px; border-radius: 10px; font-size: 14px;">
                            📷 Instagram
                        </button>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px; font-size: 12px; text-align: center;">
                        💡 İpucu: Fotoğrafı önce indirin, sonra sosyal medyada paylaşın
                    </div>
                </div>
            `;
            document.body.appendChild(shareModal);
        }

        function shareToWhatsApp() {
            const text = encodeURIComponent('AI Photo Travel ile hayal ettiğim yerde çekilmiş fotoğrafım! 🌍✈️');
            window.open(`https://wa.me/?text=${text}`, '_blank');
        }

        function shareToTwitter() {
            const text = encodeURIComponent('AI Photo Travel ile hayal ettiğim yerde çekilmiş fotoğrafım! 🌍✈️ #AIPhotoTravel #Travel #AI');
            window.open(`https://twitter.com/intent/tweet?text=${text}`, '_blank');
        }

        function shareToFacebook() {
            const url = encodeURIComponent(window.location.href);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank');
        }

        function shareToInstagram() {
            alert('Instagram\'da paylaşmak için:\n1. Fotoğrafı indirin\n2. Instagram uygulamasını açın\n3. Yeni gönderi oluşturun\n4. İndirdiğiniz fotoğrafı seçin');
        }

        // Modal dışına tıklayınca kapatma
        window.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button or banner
            const installBanner = document.createElement('div');
            installBanner.innerHTML = `
                <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 15px; border-radius: 15px; z-index: 9999; text-align: center;">
                    <p style="margin: 0 0 10px 0; font-size: 14px;">📱 Bu uygulamayı ana ekranınıza ekleyin!</p>
                    <button onclick="installApp()" style="background: #4facfe; color: white; border: none; padding: 10px 20px; border-radius: 20px; margin-right: 10px;">Yükle</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 10px 20px; border-radius: 20px;">Daha Sonra</button>
                </div>
            `;
            document.body.appendChild(installBanner);
        });

        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        }

        // Service Worker Registration with Update Handling
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    
                    console.log('Service Worker registered successfully:', registration.scope);
                    
                    // Handle service worker updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                showUpdateNotification();
                            }
                        });
                    });
                    
                    // Check for updates periodically
                    setInterval(() => {
                        registration.update();
                    }, 60000); // Check every minute
                    
                } catch (error) {
                    console.error('Service Worker registration failed:', error);
                }
            });
        }

        // Show update notification
        function showUpdateNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.innerHTML = `
                <div style="position: fixed; top: 20px; left: 20px; right: 20px; background: #4facfe; color: white; padding: 15px; border-radius: 15px; z-index: 10000; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <p style="margin: 0 0 10px 0; font-size: 14px;">🔄 Yeni bir güncelleme mevcut!</p>
                    <button onclick="reloadApp()" style="background: white; color: #4facfe; border: none; padding: 8px 16px; border-radius: 20px; margin-right: 10px; font-weight: bold;">Güncelle</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 16px; border-radius: 20px;">Daha Sonra</button>
                </div>
            `;
            document.body.appendChild(updateBanner);
        }

        // Reload app with new service worker
        function reloadApp() {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });
            }
            window.location.reload();
        }

        // Network status monitoring
        function updateNetworkStatus() {
            const isOnline = navigator.onLine;
            const statusIndicator = document.getElementById('network-status');
            
            if (!statusIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'network-status';
                indicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    padding: 5px 10px;
                    border-radius: 15px;
                    font-size: 12px;
                    z-index: 9998;
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }
            
            const indicator = document.getElementById('network-status');
            if (isOnline) {
                indicator.style.background = '#4caf50';
                indicator.style.color = 'white';
                indicator.textContent = '🟢 Çevrimiçi';
                indicator.style.opacity = '0';
                setTimeout(() => indicator.style.opacity = '0', 2000);
            } else {
                indicator.style.background = '#f44336';
                indicator.style.color = 'white';
                indicator.textContent = '🔴 Çevrimdışı';
                indicator.style.opacity = '1';
            }
        }

        // Listen for network changes
        window.addEventListener('online', updateNetworkStatus);
        window.addEventListener('offline', updateNetworkStatus);
        
        // Initial network status check
        updateNetworkStatus();

        // Performance Optimizations
        // Lazy loading for images
        function lazyLoadImages() {
            const images = document.querySelectorAll('img[data-src]');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                        imageObserver.unobserve(img);
                    }
                });
            });
            images.forEach(img => imageObserver.observe(img));
        }

        // Image compression before upload
        function compressImage(file, maxWidth = 1024, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                    canvas.width = img.width * ratio;
                    canvas.height = img.height * ratio;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };
                
                img.src = URL.createObjectURL(file);
            });
        }

        // Preload critical resources
        function preloadCriticalResources() {
            const criticalImages = [
                'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzY2N2VlYSIvPgo8cGF0aCBkPSJNMTYgOEMxMi42OSA4IDEwIDEwLjY5IDEwIDE0UzE4IDI0IDE2IDI0UzEwIDE3LjMxIDEwIDE0UzEyLjY5IDggMTYgOFoiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuOSIvPgo8L3N2Zz4K'
            ];
            
            criticalImages.forEach(src => {
                const link = document.createElement('link');
                link.rel = 'preload';
                link.as = 'image';
                link.href = src;
                document.head.appendChild(link);
            });
        }

        // Initialize performance optimizations
        document.addEventListener('DOMContentLoaded', () => {
            lazyLoadImages();
            preloadCriticalResources();
        });

        // Memory cleanup
        window.addEventListener('beforeunload', () => {
            // Clean up any remaining object URLs
            if (window.currentImageURL) {
                URL.revokeObjectURL(window.currentImageURL);
            }
        });
    </script>
    
    <!-- iPhone Specific Optimizations -->
    <style>
        /* iPhone specific improvements */
        @media screen and (max-width: 414px) {
            .app-container {
                border-radius: 0;
                max-width: 100%;
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }
            
            .header {
                padding: 70px 24px 40px;
                border-radius: 0;
            }
            
            .btn {
                min-height: 50px;
                font-size: 18px;
                padding: 18px 36px;
                border-radius: 30px;
            }
            
            .upload-area {
                padding: 50px 24px;
                margin: 20px;
                border-width: 4px;
            }
            
            .modal-content {
                width: 95%;
                margin: 20px;
                border-radius: 30px;
                padding: 40px 24px;
            }
            
            .category-card {
                padding: 28px 20px;
                border-radius: 20px;
                min-height: 120px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
        }
        
        /* iPhone X and newer with notch */
        @media screen and (max-width: 414px) and (min-height: 812px) {
            .header {
                padding-top: calc(70px + env(safe-area-inset-top));
            }
            
            .app-container {
                padding-bottom: calc(20px + env(safe-area-inset-bottom));
            }
        }
        
        /* Dark mode support for better readability */
        @media (prefers-color-scheme: dark) {
            .modal-content {
                background: rgba(26, 26, 46, 0.95);
                color: #ffffff;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .modal-title {
                color: #ffffff;
            }
            
            .modal-subtitle {
                color: #cbd5e0;
            }
        }
        
        /* High contrast mode for accessibility */
        @media (prefers-contrast: high) {
            .btn {
                border-width: 3px;
                border-color: #ffffff;
            }
            
            .upload-area {
                border-width: 4px;
                border-color: rgba(255, 255, 255, 0.8);
            }
            
            .category-card {
                border-width: 3px;
            }
        }
        
        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</body>
</html>
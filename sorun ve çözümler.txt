Projenizi analiz ettikten sonra, görüntü işleme kalitesini iyileştirmek için birkaç temel sorun ve çözüm önerisi sunacağım:
Mevcut Sorunlar
1. Arka Plan Kaldırma Sorunları

removeBackgroundPhotoscissors fonksiyonu sadece beyaz/açık renkli arka planları tespit ediyor
Basit RGB threshold kullanımı gerçek edge detection değil
API fallback'ler düzgün çalışmıyor

2. Görüntü Kalite Sorunları

Canvas boyutlandırma ve kalite ayarları optimize edilmemiş
Görüntü birleştirme algoritması basit
Gölge ve ışık efektleri yetersiz

Çözüm Önerileri
1. Gelişmiş Arka Plan Kaldırma
// Gelişmiş Canvas-based arka plan kaldırma
async function removeBackgroundAdvanced(imageFile) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Gelişmiş algoritma: GrabCut benzeri yaklaşım
            const foregroundMask = detectForeground(data, canvas.width, canvas.height);
            
            // Alpha channel'ı güncelle
            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                data[i + 3] = foregroundMask[pixelIndex] ? 255 : 0;
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            canvas.toBlob((blob) => {
                if (blob) {
                    resolve(URL.createObjectURL(blob));
                } else {
                    reject(new Error('Canvas blob oluşturulamadı'));
                }
            }, 'image/png');
        };
        
        img.onerror = () => reject(new Error('Resim yüklenemedi'));
        
        if (imageFile instanceof File || imageFile instanceof Blob) {
            const reader = new FileReader();
            reader.onload = (e) => img.src = e.target.result;
            reader.onerror = () => reject(new Error('Dosya okunamadı'));
            reader.readAsDataURL(imageFile);
        } else if (typeof imageFile === 'string') {
            img.src = imageFile;
        }
    });
}

// Gelişmiş ön plan tespit algoritması
function detectForeground(imageData, width, height) {
    const mask = new Array(width * height).fill(false);
    
    // 1. Edge detection (Sobel operator)
    const edges = detectEdges(imageData, width, height);
    
    // 2. Color clustering
    const clusters = colorClustering(imageData, width, height, 8);
    
    // 3. Histogram analizi ile dominant background rengi
    const backgroundCluster = findBackgroundCluster(clusters, width, height);
    
    // 4. Flood fill benzeri region growing
    const centerRegion = getCenterRegion(width, height, 0.4);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const pixelIdx = idx * 4;
            
            const r = imageData[pixelIdx];
            const g = imageData[pixelIdx + 1];
            const b = imageData[pixelIdx + 2];
            
            // Merkez bölgedeki pikseller muhtemelen ön plan
            if (centerRegion[idx]) {
                mask[idx] = true;
                continue;
            }
            
            // Background cluster'a ait değilse ön plan olabilir
            const cluster = getPixelCluster([r, g, b], clusters);
            if (cluster !== backgroundCluster) {
                mask[idx] = true;
                continue;
            }
            
            // Edge'lerde olan pikseller ön plan sınırı olabilir
            if (edges[idx] > 0.3) {
                const neighbors = getNeighbors(x, y, width, height);
                let foregroundNeighbors = 0;
                
                for (const [nx, ny] of neighbors) {
                    if (mask[ny * width + nx]) {
                        foregroundNeighbors++;
                    }
                }
                
                if (foregroundNeighbors > 0) {
                    mask[idx] = true;
                }
            }
        }
    }
    
    // Post-processing: Morphological operations
    return morphologicalClose(mask, width, height);
}

// Edge detection (basitleştirilmiş Sobel)
function detectEdges(imageData, width, height) {
    const edges = new Array(width * height).fill(0);
    const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
    const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let gx = 0, gy = 0;
            
            for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * width + (x + kx)) * 4;
                    const gray = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
                    const kernelIdx = (ky + 1) * 3 + (kx + 1);
                    
                    gx += gray * sobelX[kernelIdx];
                    gy += gray * sobelY[kernelIdx];
                }
            }
            
            edges[y * width + x] = Math.sqrt(gx * gx + gy * gy) / 255;
        }
    }
    
    return edges;
}

// K-means color clustering
function colorClustering(imageData, width, height, k) {
    const pixels = [];
    
    // Pikselleri RGB olarak topla
    for (let i = 0; i < imageData.length; i += 4) {
        pixels.push([imageData[i], imageData[i + 1], imageData[i + 2]]);
    }
    
    // Basit k-means (2 iterasyon)
    let centroids = [];
    for (let i = 0; i < k; i++) {
        centroids.push([
            Math.random() * 255,
            Math.random() * 255,
            Math.random() * 255
        ]);
    }
    
    for (let iter = 0; iter < 2; iter++) {
        const clusters = new Array(k).fill(null).map(() => []);
        
        // Assignment
        for (const pixel of pixels) {
            let minDist = Infinity;
            let clusterIdx = 0;
            
            for (let i = 0; i < k; i++) {
                const dist = colorDistance(pixel, centroids[i]);
                if (dist < minDist) {
                    minDist = dist;
                    clusterIdx = i;
                }
            }
            
            clusters[clusterIdx].push(pixel);
        }
        
        // Update centroids
        for (let i = 0; i < k; i++) {
            if (clusters[i].length > 0) {
                const avgR = clusters[i].reduce((sum, p) => sum + p[0], 0) / clusters[i].length;
                const avgG = clusters[i].reduce((sum, p) => sum + p[1], 0) / clusters[i].length;
                const avgB = clusters[i].reduce((sum, p) => sum + p[2], 0) / clusters[i].length;
                centroids[i] = [avgR, avgG, avgB];
            }
        }
    }
    
    return centroids;
}

// Renk mesafesi hesaplama
function colorDistance(color1, color2) {
    const dr = color1[0] - color2[0];
    const dg = color1[1] - color2[1];
    const db = color1[2] - color2[2];
    return Math.sqrt(dr * dr + dg * dg + db * db);
}

// Background cluster tespiti
function findBackgroundCluster(clusters, width, height) {
    // Genellikle köşelerdeki renkler background'dur
    const cornerColors = [
        // Top-left, top-right, bottom-left, bottom-right köşelerden sample al
    ];
    
    let backgroundIdx = 0;
    let minDist = Infinity;
    
    for (let i = 0; i < clusters.length; i++) {
        // En yaygın cluster'ı bul (basit heuristic)
        const avgCornerDist = cornerColors.reduce((sum, color) => 
            sum + colorDistance(color, clusters[i]), 0) / cornerColors.length;
            
        if (avgCornerDist < minDist) {
            minDist = avgCornerDist;
            backgroundIdx = i;
        }
    }
    
    return backgroundIdx;
}

// Merkez bölge tanımlama
function getCenterRegion(width, height, ratio) {
    const mask = new Array(width * height).fill(false);
    const centerX = width / 2;
    const centerY = height / 2;
    const radiusX = width * ratio / 2;
    const radiusY = height * ratio / 2;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const dx = (x - centerX) / radiusX;
            const dy = (y - centerY) / radiusY;
            
            if (dx * dx + dy * dy <= 1) {
                mask[y * width + x] = true;
            }
        }
    }
    
    return mask;
}

// Pixel'in hangi cluster'a ait olduğunu bul
function getPixelCluster(pixel, clusters) {
    let minDist = Infinity;
    let clusterIdx = 0;
    
    for (let i = 0; i < clusters.length; i++) {
        const dist = colorDistance(pixel, clusters[i]);
        if (dist < minDist) {
            minDist = dist;
            clusterIdx = i;
        }
    }
    
    return clusterIdx;
}

// Komşu pikselleri al
function getNeighbors(x, y, width, height) {
    const neighbors = [];
    
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            
            const nx = x + dx;
            const ny = y + dy;
            
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                neighbors.push([nx, ny]);
            }
        }
    }
    
    return neighbors;
}

// Morphological closing operation
function morphologicalClose(mask, width, height) {
    // Dilation + Erosion
    const dilated = morphologicalDilate(mask, width, height);
    return morphologicalErode(dilated, width, height);
}

function morphologicalDilate(mask, width, height) {
    const result = new Array(width * height).fill(false);
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            
            // 3x3 kernel
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (mask[(y + dy) * width + (x + dx)]) {
                        result[idx] = true;
                        break;
                    }
                }
                if (result[idx]) break;
            }
        }
    }
    
    return result;
}

function morphologicalErode(mask, width, height) {
    const result = new Array(width * height).fill(false);
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            
            let allTrue = true;
            // 3x3 kernel
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (!mask[(y + dy) * width + (x + dx)]) {
                        allTrue = false;
                        break;
                    }
                }
                if (!allTrue) break;
            }
            
            result[idx] = allTrue;
        }
    }
    
    return result;
}
2.Şimdi de gelişmiş görüntü birleştirme algoritması 
// Gelişmiş görüntü birleştirme algoritması
async function combineImagesAdvancedPro(foreground, background) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Yüksek kalite için büyük canvas boyutu
        canvas.width = 1024;
        canvas.height = 1024;
        
        const bgImg = new Image();
        const fgImg = new Image();
        
        let loadedImages = 0;
        
        const onImageLoad = () => {
            loadedImages++;
            if (loadedImages === 2) {
                // High-quality kompozisyon
                performAdvancedComposition(ctx, fgImg, bgImg, canvas.width, canvas.height);
                resolve(canvas.toDataURL('image/jpeg', 0.95));
            }
        };
        
        bgImg.onload = onImageLoad;
        fgImg.onload = onImageLoad;
        
        bgImg.src = background;
        fgImg.src = foreground;
    });
}

function performAdvancedComposition(ctx, fgImg, bgImg, canvasWidth, canvasHeight) {
    // 1. Background'u çiz ve blur efekti ekle
    drawBackgroundWithDepthOfField(ctx, bgImg, canvasWidth, canvasHeight);
    
    // 2. Foreground'u analiz et ve perspektif düzeltmesi yap
    const fgAnalysis = analyzeForegroundImage(fgImg);
    
    // 3. Lighting ve color matching
    const lightingInfo = analyzeLighting(bgImg);
    
    // 4. Foreground'u background'a uyumlu hale getir
    const adjustedForeground = adjustForegroundForBackground(fgImg, fgAnalysis, lightingInfo);
    
    // 5. Perspektif ve boyutlandırma
    const positioning = calculateOptimalPositioning(fgAnalysis, canvasWidth, canvasHeight);
    
    // 6. Gölge hesaplama
    const shadowCanvas = generateRealisticShadow(adjustedForeground, lightingInfo, positioning);
    
    // 7. Kompozisyon
    composeElements(ctx, adjustedForeground, shadowCanvas, positioning);
    
    // 8. Final touch-ups
    applyFinalAdjustments(ctx, canvasWidth, canvasHeight, lightingInfo);
}

// Background depth of field efekti
function drawBackgroundWithDepthOfField(ctx, bgImg, width, height) {
    // Background'u çiz
    ctx.drawImage(bgImg, 0, 0, width, height);
    
    // Subtle blur efekti için
    ctx.filter = 'blur(1px)';
    ctx.globalAlpha = 0.3;
    ctx.drawImage(bgImg, 0, 0, width, height);
    
    // Reset
    ctx.filter = 'none';
    ctx.globalAlpha = 1.0;
}

// Foreground görüntü analizi
function analyzeForegroundImage(fgImg) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = fgImg.width;
    tempCanvas.height = fgImg.height;
    tempCtx.drawImage(fgImg, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, fgImg.width, fgImg.height);
    
    return {
        dominantColors: extractDominantColors(imageData),
        brightness: calculateAverageBrightness(imageData),
        contrast: calculateContrast(imageData),
        bounds: findForegroundBounds(imageData),
        centerOfMass: findCenterOfMass(imageData)
    };
}

// Lighting analizi
function analyzeLighting(bgImg) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = bgImg.width;
    tempCanvas.height = bgImg.height;
    tempCtx.drawImage(bgImg, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, bgImg.width, bgImg.height);
    
    return {
        lightDirection: estimateLightDirection(imageData),
        ambientLight: calculateAmbientLight(imageData),
        colorTemperature: estimateColorTemperature(imageData),
        shadows: findShadowAreas(imageData)
    };
}

// Foreground'u background'a uyumlu hale getir
function adjustForegroundForBackground(fgImg, fgAnalysis, lightingInfo) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = fgImg.width;
    canvas.height = fgImg.height;
    
    // Renk sıcaklığı düzeltmesi
    const colorTempAdjustment = calculateColorTemperatureAdjustment(
        fgAnalysis.dominantColors,
        lightingInfo.colorTemperature
    );
    
    // Brightness/contrast matching
    const brightnessAdjustment = calculateBrightnessAdjustment(
        fgAnalysis.brightness,
        lightingInfo.ambientLight
    );
    
    // Filtreler uygula
    ctx.filter = `
        brightness(${brightnessAdjustment.brightness}) 
        contrast(${brightnessAdjustment.contrast}) 
        sepia(${colorTempAdjustment.sepia}) 
        hue-rotate(${colorTempAdjustment.hue}deg)
    `;
    
    ctx.drawImage(fgImg, 0, 0);
    
    return canvas;
}

// Optimal pozisyonlama hesaplama
function calculateOptimalPositioning(fgAnalysis, canvasWidth, canvasHeight) {
    const fgBounds = fgAnalysis.bounds;
    const aspectRatio = fgBounds.width / fgBounds.height;
    
    let targetWidth, targetHeight;
    
    // Kişi boyutuna göre oransal ölçeklendirme
    if (aspectRatio > 1) {
        // Landscape orientation (kişi yatay)
        targetWidth = canvasWidth * 0.4;
        targetHeight = targetWidth / aspectRatio;
    } else {
        // Portrait orientation (kişi dikey)
        targetHeight = canvasHeight * 0.8;
        targetWidth = targetHeight * aspectRatio;
    }
    
    // Golden ratio kullanarak pozisyon hesapla
    const goldenRatio = 1.618;
    const x = (canvasWidth - targetWidth) / goldenRatio;
    const y = canvasHeight - targetHeight - (canvasHeight * 0.1);
    
    return {
        x: Math.max(0, x),
        y: Math.max(0, y),
        width: targetWidth,
        height: targetHeight,
        scale: targetWidth / fgBounds.width
    };
}

// Gerçekçi gölge oluşturma
function generateRealisticShadow(fgCanvas, lightingInfo, positioning) {
    const shadowCanvas = document.createElement('canvas');
    const shadowCtx = shadowCanvas.getContext('2d');
    
    shadowCanvas.width = positioning.width;
    shadowCanvas.height = positioning.height;
    
    // Işık yönüne göre gölge açısı ve mesafesi
    const lightAngle = lightingInfo.lightDirection;
    const shadowOffset = {
        x: Math.cos(lightAngle) * 20 * positioning.scale,
        y: Math.sin(lightAngle) * 10 * positioning.scale
    };
    
    // Gölge blur miktarı
    const blurAmount = 15 * positioning.scale;
    
    // Gölge oluştur
    shadowCtx.filter = `blur(${blurAmount}px)`;
    shadowCtx.globalAlpha = 0.4;
    shadowCtx.fillStyle = '#000000';
    
    // Foreground şeklini temel alarak gölge şekli oluştur
    shadowCtx.drawImage(fgCanvas, shadowOffset.x, shadowOffset.y, positioning.width, positioning.height);
    
    // Gölgeyi yere yassılaştır (perspective transform)
    const transform = calculateShadowPerspective(lightAngle, positioning);
    shadowCtx.transform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
    
    return shadowCanvas;
}

// Elementleri birleştir
function composeElements(ctx, fgCanvas, shadowCanvas, positioning) {
    // 1. Önce gölgeyi çiz
    ctx.globalCompositeOperation = 'multiply';
    ctx.drawImage(shadowCanvas, positioning.x, positioning.y + positioning.height * 0.1);
    
    // 2. Foreground'u çiz
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(fgCanvas, positioning.x, positioning.y, positioning.width, positioning.height);
    
    // 3. Edge blending için soft mask uygula
    applyEdgeBlending(ctx, positioning);
}

// Final düzeltmeler
function applyFinalAdjustments(ctx, width, height, lightingInfo) {
    // 1. Genel renk harmonisi
    ctx.globalCompositeOperation = 'overlay';
    ctx.globalAlpha = 0.1;
    
    const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
    gradient.addColorStop(0, `hsl(${lightingInfo.colorTemperature}, 20%, 50%)`);
    gradient.addColorStop(1, 'transparent');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // 2. Vignette efekti
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.8;
    
    const vignetteGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
    vignetteGradient.addColorStop(0, 'white');
    vignetteGradient.addColorStop(0.7, 'white');
    vignetteGradient.addColorStop(1, '#888888');
    
    ctx.fillStyle = vignetteGradient;
    ctx.fillRect(0, 0, width, height);
    
    // Reset
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
}

// Yardımcı fonksiyonlar
function extractDominantColors(imageData) {
    const colors = [];
    const data = imageData.data;
    
    // Her 10. pikseli örnekle
    for (let i = 0; i < data.length; i += 40) {
        if (data[i + 3] > 128) { // Alpha > 128
            colors.push([data[i], data[i + 1], data[i + 2]]);
        }
    }
    
    // K-means ile dominant renkleri bul (basit versiyon)
    return colors.slice(0, 5); // İlk 5 renk
}

function calculateAverageBrightness(imageData) {
    const data = imageData.data;
    let totalBrightness = 0;
    let count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 128) {
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            totalBrightness += brightness;
            count++;
        }
    }
    
    return count > 0 ? totalBrightness / count : 128;
}

function calculateContrast(imageData) {
    // Basit contrast hesaplama
    const brightness = calculateAverageBrightness(imageData);
    const data = imageData.data;
    let variance = 0;
    let count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 128) {
            const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            variance += Math.pow(pixelBrightness - brightness, 2);
            count++;
        }
    }
    
    return count > 0 ? Math.sqrt(variance / count) : 0;
}

function findForegroundBounds(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let minX = width, minY = height, maxX = 0, maxY = 0;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 128) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }
    }
    
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}

function findCenterOfMass(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let totalX = 0, totalY = 0, totalMass = 0;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 128) {
                totalX += x * alpha;
                totalY += y * alpha;
                totalMass += alpha;
            }
        }
    }
    
    return {
        x: totalMass > 0 ? totalX / totalMass : width / 2,
        y: totalMass > 0 ? totalY / totalMass : height / 2
    };
}

function estimateLightDirection(imageData) {
    // Basit ışık yönü tahmini - gradyan analizi
    // Sol-sağ ve üst-alt brightness farkı
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let leftBrightness = 0, rightBrightness = 0;
    let topBrightness = 0, bottomBrightness = 0;
    
    // Sol yarım
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width / 2; x++) {
            const idx = (y * width + x) * 4;
            leftBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        }
    }
    
    // Sağ yarım
    for (let y = 0; y < height; y++) {
        for (let x = width / 2; x < width; x++) {
            const idx = (y * width + x) * 4;
            rightBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        }
    }
    
    const horizontalAngle = Math.atan2(rightBrightness - leftBrightness, width);
    return horizontalAngle;
}

function calculateAmbientLight(imageData) {
    return calculateAverageBrightness(imageData);
}

function estimateColorTemperature(imageData) {
    const data = imageData.data;
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        totalR += data[i];
        totalG += data[i + 1];
        totalB += data[i + 2];
        count++;
    }
    
    const avgR = totalR / count;
    const avgG = totalG / count;
    const avgB = totalB / count;
    
    // Renk sıcaklığı tahmini (basitleştirilmiş)
    const ratio = avgB / avgR;
    return ratio > 1.2 ? 'cool' : ratio < 0.8 ? 'warm' : 'neutral';
}

function findShadowAreas(imageData) {
    // Gölge alanlarını tespit et (düşük brightness alanları)
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const shadows = [];
    
    for (let y = 0; y < height; y += 10) {
        for (let x = 0; x < width; x += 10) {
            const idx = (y * width + x) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            if (brightness < 80) {
                shadows.push({ x, y, intensity: 1 - brightness / 80 });
            }
        }
    }
    
    return shadows;
}

function calculateColorTemperatureAdjustment(fgColors, bgColorTemp) {
    // Background'un renk sıcaklığına göre foreground'u ayarla
    let adjustment = { sepia: 0, hue: 0 };
    
    if (bgColorTemp === 'warm' && fgColors.length > 0) {
        // Warm background için foreground'u ısıt
        adjustment.sepia = 0.2;
        adjustment.hue = 10;
    } else if (bgColorTemp === 'cool' && fgColors.length > 0) {
        // Cool background için foreground'u soğut
        adjustment.sepia = 0.1;
        adjustment.hue = -10;
    }
    
    return adjustment;
}

function calculateBrightnessAdjustment(fgBrightness, bgAmbientLight) {
    const diff = bgAmbientLight - fgBrightness;
    const adjustment = diff / 255;
    
    return {
        brightness: Math.max(0.5, Math.min(1.5, 1 + adjustment)),
        contrast: Math.max(0.8, Math.min(1.2, 1 + adjustment * 0.5))
    };
}

function calculateShadowPerspective(lightAngle, positioning) {
    // Gölge perspektif transformasyonu
    const skewX = Math.cos(lightAngle) * 0.3;
    const skewY = Math.sin(lightAngle) * 0.1;
    
    return {
        a: 1,           // horizontal scaling
        b: skewY,       // horizontal skewing
        c: skewX,       // vertical skewing  
        d: 0.3,         // vertical scaling (flatten)
        e: 0,           // horizontal moving
        f: 0            // vertical moving
    };
}

function applyEdgeBlending(ctx, positioning) {
    // Foreground kenarlarında soft blending
    const gradient = ctx.createRadialGradient(
        positioning.x + positioning.width / 2,
        positioning.y + positioning.height / 2,
        Math.min(positioning.width, positioning.height) * 0.3,
        positioning.x + positioning.width / 2,
        positioning.y + positioning.height / 2,
        Math.min(positioning.width, positioning.height) * 0.5
    );
    
    gradient.addColorStop(0, 'rgba(255,255,255,0)');
    gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
    
    ctx.globalCompositeOperation = 'soft-light';
    ctx.fillStyle = gradient;
    ctx.fillRect(positioning.x, positioning.y, positioning.width, positioning.height);
}
3.Şimdi de API entegrasyonu ve fallback sistemi
// İyileştirilmiş API konfigürasyonu
const IMPROVED_API_CONFIG = {
    // Background removal servisleri - öncelik sırasına göre
    backgroundRemoval: {
        primary: [
            {
                name: 'huggingface_rmbg2',
                endpoint: 'https://api-inference.huggingface.co/models/briaai/RMBG-2.0',
                method: 'POST',
                headers: (token) => ({ 'Authorization': `Bearer ${token}` }),
                enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN'),
                quality: 'excellent',
                speed: 'medium'
            },
            {
                name: 'replicate_rmbg',
                endpoint: '/functions/remove-background',
                method: 'POST',
                provider: 'replicate-rmbg2',
                enabled: () => !!getEnvVariable('REPLICATE_API_TOKEN'),
                quality: 'excellent',
                speed: 'slow'
            },
            {
                name: 'removebg',
                endpoint: 'https://api.remove.bg/v1.0/removebg',
                method: 'POST',
                headers: (token) => ({ 'X-Api-Key': token }),
                enabled: () => !!getEnvVariable('REMOVEBG_TOKEN'),
                quality: 'good',
                speed: 'fast'
            }
        ],
        fallback: [
            {
                name: 'canvas_based',
                method: 'local',
                processor: 'removeBackgroundAdvanced',
                quality: 'fair',
                speed: 'fast',
                enabled: () => true
            }
        ]
    },
    
    // Image generation servisleri
    imageGeneration: {
        primary: [
            {
                name: 'huggingface_sdxl',
                endpoint: 'https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-xl-base-1.0',
                method: 'POST',
                headers: (token) => ({ 'Authorization': `Bearer ${token}` }),
                enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN'),
                quality: 'excellent',
                speed: 'slow'
            },
            {
                name: 'pollinations',
                endpoint: 'https://image.pollinations.ai/prompt/',
                method: 'GET',
                enabled: () => true,
                quality: 'good',
                speed: 'fast'
            }
        ],
        fallback: [
            {
                name: 'gradient_based',
                method: 'local',
                processor: 'generateBackgroundGradient',
                quality: 'basic',
                speed: 'very_fast',
                enabled: () => true
            }
        ]
    },
    
    // Global ayarlar
    settings: {
        maxRetries: 3,
        timeout: 30000,
        retryDelay: 2000,
        qualityThreshold: 0.7,
        fallbackEnabled: true,
        cacheResults: true,
        compressionQuality: 0.92
    }
};

// Gelişmiş API client
class SmartAPIClient {
    constructor(config) {
        this.config = config;
        this.cache = new Map();
        this.metrics = {
            requests: 0,
            successes: 0,
            failures: 0,
            averageResponseTime: 0
        };
    }
    
    async processBackgroundRemoval(imageFile, options = {}) {
        const startTime = Date.now();
        
        try {
            // Cache kontrolü
            const cacheKey = await this.generateCacheKey(imageFile);
            if (this.config.settings.cacheResults && this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Primary servislerden dene
            for (const service of this.config.backgroundRemoval.primary) {
                if (!service.enabled()) continue;
                
                try {
                    updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan kaldırılıyor...`);
                    
                    const result = await this.callService(service, imageFile, options);
                    
                    if (await this.validateResult(result, 'backgroundRemoval')) {
                        this.recordSuccess(Date.now() - startTime);
                        
                        if (this.config.settings.cacheResults) {
                            this.cache.set(cacheKey, result);
                        }
                        
                        return result;
                    }
                    
                } catch (error) {
                    console.error(`${service.name} failed:`, error);
                    this.recordFailure();
                }
            }
            
            // Fallback servisleri dene
            if (this.config.settings.fallbackEnabled) {
                for (const service of this.config.backgroundRemoval.fallback) {
                    if (!service.enabled()) continue;
                    
                    try {
                        updateLoadingMessage(`Yerel işleme ile devam ediliyor...`);
                        const result = await this.callLocalProcessor(service, imageFile, options);
                        
                        if (result) {
                            this.recordSuccess(Date.now() - startTime);
                            return result;
                        }
                        
                    } catch (error) {
                        console.error(`Fallback ${service.name} failed:`, error);
                    }
                }
            }
            
            throw new Error('Tüm arka plan kaldırma servisleri başarısız oldu');
            
        } catch (error) {
            this.recordFailure();
            throw error;
        }
    }
    
    async processImageGeneration(prompt, options = {}) {
        const startTime = Date.now();
        
        try {
            // Cache kontrolü
            const cacheKey = this.hashString(prompt + JSON.stringify(options));
            if (this.config.settings.cacheResults && this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Primary servislerden dene
            for (const service of this.config.imageGeneration.primary) {
                if (!service.enabled()) continue;
                
                try {
                    updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan oluşturuluyor...`);
                    
                    const result = await this.callService(service, prompt, options);
                    
                    if (await this.validateResult(result, 'imageGeneration')) {
                        this.recordSuccess(Date.now() - startTime);
                        
                        if (this.config.settings.cacheResults) {
                            this.cache.set(cacheKey, result);
                        }
                        
                        return result;
                    }
                    
                } catch (error) {
                    console.error(`${service.name} failed:`, error);
                    this.recordFailure();
                }
            }
            
            // Fallback servisleri dene
            if (this.config.settings.fallbackEnabled) {
                for (const service of this.config.imageGeneration.fallback) {
                    if (!service.enabled()) continue;
                    
                    try {
                        updateLoadingMessage(`Yerel arka plan oluşturuluyor...`);
                        const result = await this.callLocalProcessor(service, prompt, options);
                        
                        if (result) {
                            this.recordSuccess(Date.now() - startTime);
                            return result;
                        }
                        
                    } catch (error) {
                        console.error(`Fallback ${service.name} failed:`, error);
                    }
                }
            }
            
            throw new Error('Tüm görüntü oluşturma servisleri başarısız oldu');
            
        } catch (error) {
            this.recordFailure();
            throw error;
        }
    }
    
    async callService(service, data, options) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.config.settings.timeout);
        
        try {
            let response;
            
            if (service.name === 'pollinations') {
                // Pollinations için özel işlem
                const enhancedPrompt = this.enhancePrompt(data);
                const encodedPrompt = encodeURIComponent(enhancedPrompt);
                const imageUrl = `${service.endpoint}${encodedPrompt}?width=1024&height=1024&seed=${Math.floor(Math.random() * 1000000)}`;
                
                response = await fetch(imageUrl, { signal: controller.signal });
                
            } else if (service.endpoint.startsWith('/functions/')) {
                // Cloudflare functions için
                const formData = new FormData();
                formData.append('image_file', data);
                if (service.provider) {
                    formData.append('provider', service.provider);
                }
                
                response = await fetch(service.endpoint, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
            } else if (service.method === 'POST') {
                // Standard POST request
                const token = this.getServiceToken(service.name);
                
                if (service.name.includes('huggingface')) {
                    // Hugging Face için özel format
                    const body = typeof data === 'string' 
                        ? JSON.stringify({ inputs: this.enhancePrompt(data) })
                        : data;
                    
                    response = await fetch(service.endpoint, {
                        method: 'POST',
                        headers: {
                            ...service.headers(token),
                            ...(typeof data === 'string' && { 'Content-Type': 'application/json' })
                        },
                        body: body,
                        signal: controller.signal
                    });
                } else {
                    // Diğer servisler için FormData
                    const formData = new FormData();
                    formData.append('image_file', data);
                    
                    response = await fetch(service.endpoint, {
                        method: 'POST',
                        headers: service.headers(token),
                        body: formData,
                        signal: controller.signal
                    });
                }
            }
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }
            
            // Response type'a göre işle
            if (response.headers.get('content-type')?.includes('application/json')) {
                const json = await response.json();
                
                // Hugging Face error handling
                if (json.error) {
                    throw new Error(`Service error: ${json.error}`);
                }
                
                return json;
            } else {
                const blob = await response.blob();
                return URL.createObjectURL(blob);
            }
            
        } finally {
            clearTimeout(timeoutId);
        }
    }
    
    async callLocalProcessor(service, data, options) {
        switch (service.processor) {
            case 'removeBackgroundAdvanced':
                return await removeBackgroundAdvanced(data);
                
            case 'generateBackgroundGradient':
                return await this.generateBackgroundGradient(data, options);
                
            default:
                throw new Error(`Unknown local processor: ${service.processor}`);
        }
    }
    
    async generateBackgroundGradient(prompt, options) {
        // Lokasyon ve parametrelere göre gradient arka plan oluştur
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1024;
        canvas.height = 1024;
        
        // Prompt'dan renk çıkar
        const colors = this.extractColorsFromPrompt(prompt);
        
        // Gradient oluştur
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, colors.primary);
        gradient.addColorStop(0.5, colors.secondary);
        gradient.addColorStop(1, colors.accent);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Texture ekle
        this.addTextureToCanvas(ctx, canvas.width, canvas.height, prompt);
        
        return canvas.toDataURL('image/jpeg', this.config.settings.compressionQuality);
    }
    
    extractColorsFromPrompt(prompt) {
        const colorMap = {
            'paris': { primary: '#87CEEB', secondary: '#F0F8FF', accent: '#FFD700' },
            'tokyo': { primary: '#FF69B4', secondary: '#9370DB', accent: '#00CED1' },
            'newyork': { primary: '#696969', secondary: '#A9A9A9', accent: '#FFD700' },
            'istanbul': { primary: '#4682B4', secondary: '#F0E68C', accent: '#CD853F' },
            'dubai': { primary: '#F4A460', secondary: '#DEB887', accent: '#CD853F' },
            'sunset': { primary: '#FF4500', secondary: '#FFA500', accent: '#FFD700' },
            'morning': { primary: '#87CEEB', secondary: '#E0E6FA', accent: '#FFFAF0' },
            'night': { primary: '#191970', secondary: '#2F2F4F', accent: '#4169E1' },
            'default': { primary: '#87CEEB', secondary: '#F0F8FF', accent: '#FFD700' }
        };
        
        const promptLower = prompt.toLowerCase();
        
        for (const [key, colors] of Object.entries(colorMap)) {
            if (promptLower.includes(key)) {
                return colors;
            }
        }
        
        return colorMap.default;
    }
    
    addTextureToCanvas(ctx, width, height, prompt) {
        // Basit texture pattern ekle
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = '#FFFFFF';
        
        // Prompt'a göre pattern seç
        if (prompt.includes('city') || prompt.includes('urban')) {
            // Urban pattern
            for (let x = 0; x < width; x += 50) {
                for (let y = 0; y < height; y += 50) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(x, y, 2, 20);
                        ctx.fillRect(x, y, 20, 2);
                    }
                }
            }
        } else if (prompt.includes('nature') || prompt.includes('landscape')) {
            // Organic pattern
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 10 + 5;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        ctx.globalAlpha = 1.0;
    }
    
    enhancePrompt(prompt) {
        const enhancements = [
            'professional photography',
            'high quality',
            'detailed',
            '8k resolution',
            'cinematic lighting',
            'realistic',
            'sharp focus'
        ];
        
        return `${prompt}, ${enhancements.join(', ')}`;
    }
    
    getServiceToken(serviceName) {
        const tokenMap = {
            'huggingface_rmbg2': 'HUGGING_FACE_TOKEN',
            'huggingface_sdxl': 'HUGGING_FACE_TOKEN',
            'replicate_rmbg': 'REPLICATE_API_TOKEN',
            'removebg': 'REMOVEBG_TOKEN'
        };
        
        return getEnvVariable(tokenMap[serviceName]);
    }
    
    async validateResult(result, type) {
        if (!result) return false;
        
        if (type === 'backgroundRemoval') {
            // URL veya blob kontrolü
            return typeof result === 'string' && result.startsWith('blob:');
        }
        
        if (type === 'imageGeneration') {
            // URL, blob veya base64 kontrolü
            return typeof result === 'string' && 
                   (result.startsWith('blob:') || 
                    result.startsWith('data:image/') ||
                    result.startsWith('http'));
        }
        
        return false;
    }
    
    async generateCacheKey(file) {
        // File hash oluştur (basit versiyon)
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-1', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 32-bit integer'a dönüştür
        }
        return hash.toString();
    }
    
    recordSuccess(responseTime) {
        this.metrics.requests++;
        this.metrics.successes++;
        this.metrics.averageResponseTime = 
            (this.metrics.averageResponseTime * (this.metrics.successes - 1) + responseTime) / 
            this.metrics.successes;
    }
    
    recordFailure() {
        this.metrics.requests++;
        this.metrics.failures++;
    }
    
    getMetrics() {
        return {
            ...this.metrics,
            successRate: this.metrics.requests > 0 ? 
                (this.metrics.successes / this.metrics.requests) * 100 : 0
        };
    }
}

// Global API client instance
const apiClient = new SmartAPIClient(IMPROVED_API_CONFIG);

// Güncellenen ana fonksiyonlar
async function removeBackgroundWithRetry(imageFile) {
    return await apiClient.processBackgroundRemoval(imageFile);
}

async function generateBackgroundWithRetry(prompt) {
    return await apiClient.processImageGeneration(prompt);
}

// Progress tracking ile birleştirilmiş ana fonksiyon
async function generatePhotoImproved() {
    if (!selectedPhoto || !selectedLocation) {
        showError('Eksik Bilgi', 'Lütfen fotoğraf ve lokasyon seçin!');
        return;
    }

    closeModal('parametersModal');
    document.getElementById('uploadSection').style.display = 'none';
    hideError();
    
    lastOperation = generatePhotoImproved;
    
    try {
        // Step 1: Image preparation (15%)
        showLoading('🖼️ Fotoğraf Hazırlanıyor', 'Görüntü optimize ediliyor...');
        updateProgress(5);
        
        const optimizedImage = await optimizeImageForProcessing(selectedPhoto);
        updateProgress(15);
        
        // Step 2: Advanced background removal (40%)
        updateLoadingTitle('✂️ Arka Plan Kaldırılıyor');
        updateLoadingMessage('AI ile gelişmiş arka plan temizleme...');
        updateProgress(20);
        
        const backgroundRemovedImage = await removeBackgroundWithRetry(optimizedImage);
        updateProgress(40);
        
        // Step 3: Enhanced background generation (70%)
        updateLoadingTitle('🎨 Yeni Arka Plan Oluşturuluyor');
        updateLoadingMessage(`${selectedLocation.name} için sahne hazırlanıyor...`);
        updateProgress(45);
        
        const enhancedPrompt = createEnhancedPrompt();
        const newBackground = await generateBackgroundWithRetry(enhancedPrompt);
        updateProgress(70);
        
        // Step 4: Advanced composition (90%)
        updateLoadingTitle('🔄 Profesyonel Birleştirme');
        updateLoadingMessage('Işık, gölge ve perspektif ayarlanıyor...');
        updateProgress(75);
        
        const finalImage = await combineImagesAdvancedPro(backgroundRemovedImage, newBackground);
        updateProgress(90);
        
        // Step 5: Final optimization (100%)
        updateLoadingMessage('Son dokunuşlar ve optimizasyon...');
        const optimizedFinalImage = await applyFinalOptimizations(finalImage);
        updateProgress(100);
        
        setTimeout(() => {
            hideLoading();
            document.getElementById('previewSection').style.display = 'block';
            document.getElementById('previewImage').src = optimizedFinalImage;
            document.getElementById('shareBtn').style.display = 'inline-block';
        }, 500);
        
    } catch (error) {
        console.error('Gelişmiş AI işleme hatası:', error);
        handleProcessingError(error);
    }
}

// Yardımcı fonksiyonlar
async function optimizeImageForProcessing(imageFile) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve) => {
        img.onload = () => {
            // Optimal boyutlandırma
            const maxSize = 768; // Yüksek kalite için büyük boyut
            let { width, height } = img;
            
            if (width > height) {
                if (width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                }
            } else {
                if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Yüksek kalite rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            ctx.drawImage(img, 0, 0, width, height);
            
            canvas.toBlob(resolve, 'image/jpeg', 0.95);
        };
        
        img.src = URL.createObjectURL(imageFile);
    });
}

function createEnhancedPrompt() {
    const basePrompt = createPrompt(); // Mevcut fonksiyon
    
    // Quality boosters
    const qualityEnhancers = [
        'award winning photography',
        'professional composition',
        'perfect lighting',
        'ultra sharp details',
        'realistic textures',
        'cinematic quality',
        'depth of field',
        'color grading'
    ];
    
    // Negative prompts
    const negativePrompts = [
        'blurry',
        'low quality',
        'pixelated',
        'distorted',
        'artificial',
        'fake',
        'oversaturated'
    ];
    
    return `${basePrompt}, ${qualityEnhancers.join(', ')}, NOT ${negativePrompts.join(', NOT ')}`;
}

async function applyFinalOptimizations(imageDataUrl) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve) => {
        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            
            // Yüksek kalite çizim
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0);
            
            // Son kalite optimizasyonu
            resolve(canvas.toDataURL('image/jpeg', 0.92));
        };
        
        img.src = imageDataUrl;
    });
}

function handleProcessingError(error) {
    const metrics = apiClient.getMetrics();
    
    let errorTitle = 'İşlem Hatası';
    let errorMessage = 'Bir hata oluştu. Lütfen tekrar deneyin.';
    
    if (error.message.includes('network')) {
        errorTitle = 'Bağlantı Hatası';
        errorMessage = 'İnternet bağlantınızı kontrol edin ve tekrar deneyin.';
    } else if (error.message.includes('timeout')) {
        errorTitle = 'Zaman Aşımı';
        errorMessage = 'İşlem çok uzun sürdü. Daha küçük bir fotoğraf deneyin.';
    } else if (metrics.successRate < 50) {
        errorTitle = 'Servis Hatası';
        errorMessage = 'API servisleri şu anda sorunlu. Demo sonuç gösterilecek.';
        
        setTimeout(() => {
            hideError();
            showDemoResult();
        }, 2000);
    }
    
    showError(errorTitle, errorMessage, generatePhotoImproved);
}
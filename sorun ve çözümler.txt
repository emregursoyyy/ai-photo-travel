Projenizi analiz ettikten sonra, g√∂r√ºnt√º i≈üleme kalitesini iyile≈ütirmek i√ßin birka√ß temel sorun ve √ß√∂z√ºm √∂nerisi sunacaƒüƒ±m:
Mevcut Sorunlar
1. Arka Plan Kaldƒ±rma Sorunlarƒ±

removeBackgroundPhotoscissors fonksiyonu sadece beyaz/a√ßƒ±k renkli arka planlarƒ± tespit ediyor
Basit RGB threshold kullanƒ±mƒ± ger√ßek edge detection deƒüil
API fallback'ler d√ºzg√ºn √ßalƒ±≈ümƒ±yor

2. G√∂r√ºnt√º Kalite Sorunlarƒ±

Canvas boyutlandƒ±rma ve kalite ayarlarƒ± optimize edilmemi≈ü
G√∂r√ºnt√º birle≈ütirme algoritmasƒ± basit
G√∂lge ve ƒ±≈üƒ±k efektleri yetersiz

√á√∂z√ºm √ñnerileri
1. Geli≈ümi≈ü Arka Plan Kaldƒ±rma
// Geli≈ümi≈ü Canvas-based arka plan kaldƒ±rma
async function removeBackgroundAdvanced(imageFile) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Geli≈ümi≈ü algoritma: GrabCut benzeri yakla≈üƒ±m
            const foregroundMask = detectForeground(data, canvas.width, canvas.height);
            
            // Alpha channel'ƒ± g√ºncelle
            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                data[i + 3] = foregroundMask[pixelIndex] ? 255 : 0;
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            canvas.toBlob((blob) => {
                if (blob) {
                    resolve(URL.createObjectURL(blob));
                } else {
                    reject(new Error('Canvas blob olu≈üturulamadƒ±'));
                }
            }, 'image/png');
        };
        
        img.onerror = () => reject(new Error('Resim y√ºklenemedi'));
        
        if (imageFile instanceof File || imageFile instanceof Blob) {
            const reader = new FileReader();
            reader.onload = (e) => img.src = e.target.result;
            reader.onerror = () => reject(new Error('Dosya okunamadƒ±'));
            reader.readAsDataURL(imageFile);
        } else if (typeof imageFile === 'string') {
            img.src = imageFile;
        }
    });
}

// Geli≈ümi≈ü √∂n plan tespit algoritmasƒ±
function detectForeground(imageData, width, height) {
    const mask = new Array(width * height).fill(false);
    
    // 1. Edge detection (Sobel operator)
    const edges = detectEdges(imageData, width, height);
    
    // 2. Color clustering
    const clusters = colorClustering(imageData, width, height, 8);
    
    // 3. Histogram analizi ile dominant background rengi
    const backgroundCluster = findBackgroundCluster(clusters, width, height);
    
    // 4. Flood fill benzeri region growing
    const centerRegion = getCenterRegion(width, height, 0.4);
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const pixelIdx = idx * 4;
            
            const r = imageData[pixelIdx];
            const g = imageData[pixelIdx + 1];
            const b = imageData[pixelIdx + 2];
            
            // Merkez b√∂lgedeki pikseller muhtemelen √∂n plan
            if (centerRegion[idx]) {
                mask[idx] = true;
                continue;
            }
            
            // Background cluster'a ait deƒüilse √∂n plan olabilir
            const cluster = getPixelCluster([r, g, b], clusters);
            if (cluster !== backgroundCluster) {
                mask[idx] = true;
                continue;
            }
            
            // Edge'lerde olan pikseller √∂n plan sƒ±nƒ±rƒ± olabilir
            if (edges[idx] > 0.3) {
                const neighbors = getNeighbors(x, y, width, height);
                let foregroundNeighbors = 0;
                
                for (const [nx, ny] of neighbors) {
                    if (mask[ny * width + nx]) {
                        foregroundNeighbors++;
                    }
                }
                
                if (foregroundNeighbors > 0) {
                    mask[idx] = true;
                }
            }
        }
    }
    
    // Post-processing: Morphological operations
    return morphologicalClose(mask, width, height);
}

// Edge detection (basitle≈ütirilmi≈ü Sobel)
function detectEdges(imageData, width, height) {
    const edges = new Array(width * height).fill(0);
    const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
    const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let gx = 0, gy = 0;
            
            for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * width + (x + kx)) * 4;
                    const gray = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
                    const kernelIdx = (ky + 1) * 3 + (kx + 1);
                    
                    gx += gray * sobelX[kernelIdx];
                    gy += gray * sobelY[kernelIdx];
                }
            }
            
            edges[y * width + x] = Math.sqrt(gx * gx + gy * gy) / 255;
        }
    }
    
    return edges;
}

// K-means color clustering
function colorClustering(imageData, width, height, k) {
    const pixels = [];
    
    // Pikselleri RGB olarak topla
    for (let i = 0; i < imageData.length; i += 4) {
        pixels.push([imageData[i], imageData[i + 1], imageData[i + 2]]);
    }
    
    // Basit k-means (2 iterasyon)
    let centroids = [];
    for (let i = 0; i < k; i++) {
        centroids.push([
            Math.random() * 255,
            Math.random() * 255,
            Math.random() * 255
        ]);
    }
    
    for (let iter = 0; iter < 2; iter++) {
        const clusters = new Array(k).fill(null).map(() => []);
        
        // Assignment
        for (const pixel of pixels) {
            let minDist = Infinity;
            let clusterIdx = 0;
            
            for (let i = 0; i < k; i++) {
                const dist = colorDistance(pixel, centroids[i]);
                if (dist < minDist) {
                    minDist = dist;
                    clusterIdx = i;
                }
            }
            
            clusters[clusterIdx].push(pixel);
        }
        
        // Update centroids
        for (let i = 0; i < k; i++) {
            if (clusters[i].length > 0) {
                const avgR = clusters[i].reduce((sum, p) => sum + p[0], 0) / clusters[i].length;
                const avgG = clusters[i].reduce((sum, p) => sum + p[1], 0) / clusters[i].length;
                const avgB = clusters[i].reduce((sum, p) => sum + p[2], 0) / clusters[i].length;
                centroids[i] = [avgR, avgG, avgB];
            }
        }
    }
    
    return centroids;
}

// Renk mesafesi hesaplama
function colorDistance(color1, color2) {
    const dr = color1[0] - color2[0];
    const dg = color1[1] - color2[1];
    const db = color1[2] - color2[2];
    return Math.sqrt(dr * dr + dg * dg + db * db);
}

// Background cluster tespiti
function findBackgroundCluster(clusters, width, height) {
    // Genellikle k√∂≈üelerdeki renkler background'dur
    const cornerColors = [
        // Top-left, top-right, bottom-left, bottom-right k√∂≈üelerden sample al
    ];
    
    let backgroundIdx = 0;
    let minDist = Infinity;
    
    for (let i = 0; i < clusters.length; i++) {
        // En yaygƒ±n cluster'ƒ± bul (basit heuristic)
        const avgCornerDist = cornerColors.reduce((sum, color) => 
            sum + colorDistance(color, clusters[i]), 0) / cornerColors.length;
            
        if (avgCornerDist < minDist) {
            minDist = avgCornerDist;
            backgroundIdx = i;
        }
    }
    
    return backgroundIdx;
}

// Merkez b√∂lge tanƒ±mlama
function getCenterRegion(width, height, ratio) {
    const mask = new Array(width * height).fill(false);
    const centerX = width / 2;
    const centerY = height / 2;
    const radiusX = width * ratio / 2;
    const radiusY = height * ratio / 2;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const dx = (x - centerX) / radiusX;
            const dy = (y - centerY) / radiusY;
            
            if (dx * dx + dy * dy <= 1) {
                mask[y * width + x] = true;
            }
        }
    }
    
    return mask;
}

// Pixel'in hangi cluster'a ait olduƒüunu bul
function getPixelCluster(pixel, clusters) {
    let minDist = Infinity;
    let clusterIdx = 0;
    
    for (let i = 0; i < clusters.length; i++) {
        const dist = colorDistance(pixel, clusters[i]);
        if (dist < minDist) {
            minDist = dist;
            clusterIdx = i;
        }
    }
    
    return clusterIdx;
}

// Kom≈üu pikselleri al
function getNeighbors(x, y, width, height) {
    const neighbors = [];
    
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            
            const nx = x + dx;
            const ny = y + dy;
            
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                neighbors.push([nx, ny]);
            }
        }
    }
    
    return neighbors;
}

// Morphological closing operation
function morphologicalClose(mask, width, height) {
    // Dilation + Erosion
    const dilated = morphologicalDilate(mask, width, height);
    return morphologicalErode(dilated, width, height);
}

function morphologicalDilate(mask, width, height) {
    const result = new Array(width * height).fill(false);
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            
            // 3x3 kernel
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (mask[(y + dy) * width + (x + dx)]) {
                        result[idx] = true;
                        break;
                    }
                }
                if (result[idx]) break;
            }
        }
    }
    
    return result;
}

function morphologicalErode(mask, width, height) {
    const result = new Array(width * height).fill(false);
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            
            let allTrue = true;
            // 3x3 kernel
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (!mask[(y + dy) * width + (x + dx)]) {
                        allTrue = false;
                        break;
                    }
                }
                if (!allTrue) break;
            }
            
            result[idx] = allTrue;
        }
    }
    
    return result;
}
2.≈ûimdi de geli≈ümi≈ü g√∂r√ºnt√º birle≈ütirme algoritmasƒ± 
// Geli≈ümi≈ü g√∂r√ºnt√º birle≈ütirme algoritmasƒ±
async function combineImagesAdvancedPro(foreground, background) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Y√ºksek kalite i√ßin b√ºy√ºk canvas boyutu
        canvas.width = 1024;
        canvas.height = 1024;
        
        const bgImg = new Image();
        const fgImg = new Image();
        
        let loadedImages = 0;
        
        const onImageLoad = () => {
            loadedImages++;
            if (loadedImages === 2) {
                // High-quality kompozisyon
                performAdvancedComposition(ctx, fgImg, bgImg, canvas.width, canvas.height);
                resolve(canvas.toDataURL('image/jpeg', 0.95));
            }
        };
        
        bgImg.onload = onImageLoad;
        fgImg.onload = onImageLoad;
        
        bgImg.src = background;
        fgImg.src = foreground;
    });
}

function performAdvancedComposition(ctx, fgImg, bgImg, canvasWidth, canvasHeight) {
    // 1. Background'u √ßiz ve blur efekti ekle
    drawBackgroundWithDepthOfField(ctx, bgImg, canvasWidth, canvasHeight);
    
    // 2. Foreground'u analiz et ve perspektif d√ºzeltmesi yap
    const fgAnalysis = analyzeForegroundImage(fgImg);
    
    // 3. Lighting ve color matching
    const lightingInfo = analyzeLighting(bgImg);
    
    // 4. Foreground'u background'a uyumlu hale getir
    const adjustedForeground = adjustForegroundForBackground(fgImg, fgAnalysis, lightingInfo);
    
    // 5. Perspektif ve boyutlandƒ±rma
    const positioning = calculateOptimalPositioning(fgAnalysis, canvasWidth, canvasHeight);
    
    // 6. G√∂lge hesaplama
    const shadowCanvas = generateRealisticShadow(adjustedForeground, lightingInfo, positioning);
    
    // 7. Kompozisyon
    composeElements(ctx, adjustedForeground, shadowCanvas, positioning);
    
    // 8. Final touch-ups
    applyFinalAdjustments(ctx, canvasWidth, canvasHeight, lightingInfo);
}

// Background depth of field efekti
function drawBackgroundWithDepthOfField(ctx, bgImg, width, height) {
    // Background'u √ßiz
    ctx.drawImage(bgImg, 0, 0, width, height);
    
    // Subtle blur efekti i√ßin
    ctx.filter = 'blur(1px)';
    ctx.globalAlpha = 0.3;
    ctx.drawImage(bgImg, 0, 0, width, height);
    
    // Reset
    ctx.filter = 'none';
    ctx.globalAlpha = 1.0;
}

// Foreground g√∂r√ºnt√º analizi
function analyzeForegroundImage(fgImg) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = fgImg.width;
    tempCanvas.height = fgImg.height;
    tempCtx.drawImage(fgImg, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, fgImg.width, fgImg.height);
    
    return {
        dominantColors: extractDominantColors(imageData),
        brightness: calculateAverageBrightness(imageData),
        contrast: calculateContrast(imageData),
        bounds: findForegroundBounds(imageData),
        centerOfMass: findCenterOfMass(imageData)
    };
}

// Lighting analizi
function analyzeLighting(bgImg) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = bgImg.width;
    tempCanvas.height = bgImg.height;
    tempCtx.drawImage(bgImg, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, bgImg.width, bgImg.height);
    
    return {
        lightDirection: estimateLightDirection(imageData),
        ambientLight: calculateAmbientLight(imageData),
        colorTemperature: estimateColorTemperature(imageData),
        shadows: findShadowAreas(imageData)
    };
}

// Foreground'u background'a uyumlu hale getir
function adjustForegroundForBackground(fgImg, fgAnalysis, lightingInfo) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = fgImg.width;
    canvas.height = fgImg.height;
    
    // Renk sƒ±caklƒ±ƒüƒ± d√ºzeltmesi
    const colorTempAdjustment = calculateColorTemperatureAdjustment(
        fgAnalysis.dominantColors,
        lightingInfo.colorTemperature
    );
    
    // Brightness/contrast matching
    const brightnessAdjustment = calculateBrightnessAdjustment(
        fgAnalysis.brightness,
        lightingInfo.ambientLight
    );
    
    // Filtreler uygula
    ctx.filter = `
        brightness(${brightnessAdjustment.brightness}) 
        contrast(${brightnessAdjustment.contrast}) 
        sepia(${colorTempAdjustment.sepia}) 
        hue-rotate(${colorTempAdjustment.hue}deg)
    `;
    
    ctx.drawImage(fgImg, 0, 0);
    
    return canvas;
}

// Optimal pozisyonlama hesaplama
function calculateOptimalPositioning(fgAnalysis, canvasWidth, canvasHeight) {
    const fgBounds = fgAnalysis.bounds;
    const aspectRatio = fgBounds.width / fgBounds.height;
    
    let targetWidth, targetHeight;
    
    // Ki≈üi boyutuna g√∂re oransal √∂l√ßeklendirme
    if (aspectRatio > 1) {
        // Landscape orientation (ki≈üi yatay)
        targetWidth = canvasWidth * 0.4;
        targetHeight = targetWidth / aspectRatio;
    } else {
        // Portrait orientation (ki≈üi dikey)
        targetHeight = canvasHeight * 0.8;
        targetWidth = targetHeight * aspectRatio;
    }
    
    // Golden ratio kullanarak pozisyon hesapla
    const goldenRatio = 1.618;
    const x = (canvasWidth - targetWidth) / goldenRatio;
    const y = canvasHeight - targetHeight - (canvasHeight * 0.1);
    
    return {
        x: Math.max(0, x),
        y: Math.max(0, y),
        width: targetWidth,
        height: targetHeight,
        scale: targetWidth / fgBounds.width
    };
}

// Ger√ßek√ßi g√∂lge olu≈üturma
function generateRealisticShadow(fgCanvas, lightingInfo, positioning) {
    const shadowCanvas = document.createElement('canvas');
    const shadowCtx = shadowCanvas.getContext('2d');
    
    shadowCanvas.width = positioning.width;
    shadowCanvas.height = positioning.height;
    
    // I≈üƒ±k y√∂n√ºne g√∂re g√∂lge a√ßƒ±sƒ± ve mesafesi
    const lightAngle = lightingInfo.lightDirection;
    const shadowOffset = {
        x: Math.cos(lightAngle) * 20 * positioning.scale,
        y: Math.sin(lightAngle) * 10 * positioning.scale
    };
    
    // G√∂lge blur miktarƒ±
    const blurAmount = 15 * positioning.scale;
    
    // G√∂lge olu≈ütur
    shadowCtx.filter = `blur(${blurAmount}px)`;
    shadowCtx.globalAlpha = 0.4;
    shadowCtx.fillStyle = '#000000';
    
    // Foreground ≈üeklini temel alarak g√∂lge ≈üekli olu≈ütur
    shadowCtx.drawImage(fgCanvas, shadowOffset.x, shadowOffset.y, positioning.width, positioning.height);
    
    // G√∂lgeyi yere yassƒ±la≈ütƒ±r (perspective transform)
    const transform = calculateShadowPerspective(lightAngle, positioning);
    shadowCtx.transform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
    
    return shadowCanvas;
}

// Elementleri birle≈ütir
function composeElements(ctx, fgCanvas, shadowCanvas, positioning) {
    // 1. √ñnce g√∂lgeyi √ßiz
    ctx.globalCompositeOperation = 'multiply';
    ctx.drawImage(shadowCanvas, positioning.x, positioning.y + positioning.height * 0.1);
    
    // 2. Foreground'u √ßiz
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(fgCanvas, positioning.x, positioning.y, positioning.width, positioning.height);
    
    // 3. Edge blending i√ßin soft mask uygula
    applyEdgeBlending(ctx, positioning);
}

// Final d√ºzeltmeler
function applyFinalAdjustments(ctx, width, height, lightingInfo) {
    // 1. Genel renk harmonisi
    ctx.globalCompositeOperation = 'overlay';
    ctx.globalAlpha = 0.1;
    
    const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
    gradient.addColorStop(0, `hsl(${lightingInfo.colorTemperature}, 20%, 50%)`);
    gradient.addColorStop(1, 'transparent');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // 2. Vignette efekti
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.8;
    
    const vignetteGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
    vignetteGradient.addColorStop(0, 'white');
    vignetteGradient.addColorStop(0.7, 'white');
    vignetteGradient.addColorStop(1, '#888888');
    
    ctx.fillStyle = vignetteGradient;
    ctx.fillRect(0, 0, width, height);
    
    // Reset
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
}

// Yardƒ±mcƒ± fonksiyonlar
function extractDominantColors(imageData) {
    const colors = [];
    const data = imageData.data;
    
    // Her 10. pikseli √∂rnekle
    for (let i = 0; i < data.length; i += 40) {
        if (data[i + 3] > 128) { // Alpha > 128
            colors.push([data[i], data[i + 1], data[i + 2]]);
        }
    }
    
    // K-means ile dominant renkleri bul (basit versiyon)
    return colors.slice(0, 5); // ƒ∞lk 5 renk
}

function calculateAverageBrightness(imageData) {
    const data = imageData.data;
    let totalBrightness = 0;
    let count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 128) {
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            totalBrightness += brightness;
            count++;
        }
    }
    
    return count > 0 ? totalBrightness / count : 128;
}

function calculateContrast(imageData) {
    // Basit contrast hesaplama
    const brightness = calculateAverageBrightness(imageData);
    const data = imageData.data;
    let variance = 0;
    let count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 128) {
            const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            variance += Math.pow(pixelBrightness - brightness, 2);
            count++;
        }
    }
    
    return count > 0 ? Math.sqrt(variance / count) : 0;
}

function findForegroundBounds(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let minX = width, minY = height, maxX = 0, maxY = 0;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 128) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }
    }
    
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}

function findCenterOfMass(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let totalX = 0, totalY = 0, totalMass = 0;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 128) {
                totalX += x * alpha;
                totalY += y * alpha;
                totalMass += alpha;
            }
        }
    }
    
    return {
        x: totalMass > 0 ? totalX / totalMass : width / 2,
        y: totalMass > 0 ? totalY / totalMass : height / 2
    };
}

function estimateLightDirection(imageData) {
    // Basit ƒ±≈üƒ±k y√∂n√º tahmini - gradyan analizi
    // Sol-saƒü ve √ºst-alt brightness farkƒ±
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    let leftBrightness = 0, rightBrightness = 0;
    let topBrightness = 0, bottomBrightness = 0;
    
    // Sol yarƒ±m
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width / 2; x++) {
            const idx = (y * width + x) * 4;
            leftBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        }
    }
    
    // Saƒü yarƒ±m
    for (let y = 0; y < height; y++) {
        for (let x = width / 2; x < width; x++) {
            const idx = (y * width + x) * 4;
            rightBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        }
    }
    
    const horizontalAngle = Math.atan2(rightBrightness - leftBrightness, width);
    return horizontalAngle;
}

function calculateAmbientLight(imageData) {
    return calculateAverageBrightness(imageData);
}

function estimateColorTemperature(imageData) {
    const data = imageData.data;
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        totalR += data[i];
        totalG += data[i + 1];
        totalB += data[i + 2];
        count++;
    }
    
    const avgR = totalR / count;
    const avgG = totalG / count;
    const avgB = totalB / count;
    
    // Renk sƒ±caklƒ±ƒüƒ± tahmini (basitle≈ütirilmi≈ü)
    const ratio = avgB / avgR;
    return ratio > 1.2 ? 'cool' : ratio < 0.8 ? 'warm' : 'neutral';
}

function findShadowAreas(imageData) {
    // G√∂lge alanlarƒ±nƒ± tespit et (d√º≈ü√ºk brightness alanlarƒ±)
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const shadows = [];
    
    for (let y = 0; y < height; y += 10) {
        for (let x = 0; x < width; x += 10) {
            const idx = (y * width + x) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            if (brightness < 80) {
                shadows.push({ x, y, intensity: 1 - brightness / 80 });
            }
        }
    }
    
    return shadows;
}

function calculateColorTemperatureAdjustment(fgColors, bgColorTemp) {
    // Background'un renk sƒ±caklƒ±ƒüƒ±na g√∂re foreground'u ayarla
    let adjustment = { sepia: 0, hue: 0 };
    
    if (bgColorTemp === 'warm' && fgColors.length > 0) {
        // Warm background i√ßin foreground'u ƒ±sƒ±t
        adjustment.sepia = 0.2;
        adjustment.hue = 10;
    } else if (bgColorTemp === 'cool' && fgColors.length > 0) {
        // Cool background i√ßin foreground'u soƒüut
        adjustment.sepia = 0.1;
        adjustment.hue = -10;
    }
    
    return adjustment;
}

function calculateBrightnessAdjustment(fgBrightness, bgAmbientLight) {
    const diff = bgAmbientLight - fgBrightness;
    const adjustment = diff / 255;
    
    return {
        brightness: Math.max(0.5, Math.min(1.5, 1 + adjustment)),
        contrast: Math.max(0.8, Math.min(1.2, 1 + adjustment * 0.5))
    };
}

function calculateShadowPerspective(lightAngle, positioning) {
    // G√∂lge perspektif transformasyonu
    const skewX = Math.cos(lightAngle) * 0.3;
    const skewY = Math.sin(lightAngle) * 0.1;
    
    return {
        a: 1,           // horizontal scaling
        b: skewY,       // horizontal skewing
        c: skewX,       // vertical skewing  
        d: 0.3,         // vertical scaling (flatten)
        e: 0,           // horizontal moving
        f: 0            // vertical moving
    };
}

function applyEdgeBlending(ctx, positioning) {
    // Foreground kenarlarƒ±nda soft blending
    const gradient = ctx.createRadialGradient(
        positioning.x + positioning.width / 2,
        positioning.y + positioning.height / 2,
        Math.min(positioning.width, positioning.height) * 0.3,
        positioning.x + positioning.width / 2,
        positioning.y + positioning.height / 2,
        Math.min(positioning.width, positioning.height) * 0.5
    );
    
    gradient.addColorStop(0, 'rgba(255,255,255,0)');
    gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
    
    ctx.globalCompositeOperation = 'soft-light';
    ctx.fillStyle = gradient;
    ctx.fillRect(positioning.x, positioning.y, positioning.width, positioning.height);
}
3.≈ûimdi de API entegrasyonu ve fallback sistemi
// ƒ∞yile≈ütirilmi≈ü API konfig√ºrasyonu
const IMPROVED_API_CONFIG = {
    // Background removal servisleri - √∂ncelik sƒ±rasƒ±na g√∂re
    backgroundRemoval: {
        primary: [
            {
                name: 'huggingface_rmbg2',
                endpoint: 'https://api-inference.huggingface.co/models/briaai/RMBG-2.0',
                method: 'POST',
                headers: (token) => ({ 'Authorization': `Bearer ${token}` }),
                enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN'),
                quality: 'excellent',
                speed: 'medium'
            },
            {
                name: 'replicate_rmbg',
                endpoint: '/functions/remove-background',
                method: 'POST',
                provider: 'replicate-rmbg2',
                enabled: () => !!getEnvVariable('REPLICATE_API_TOKEN'),
                quality: 'excellent',
                speed: 'slow'
            },
            {
                name: 'removebg',
                endpoint: 'https://api.remove.bg/v1.0/removebg',
                method: 'POST',
                headers: (token) => ({ 'X-Api-Key': token }),
                enabled: () => !!getEnvVariable('REMOVEBG_TOKEN'),
                quality: 'good',
                speed: 'fast'
            }
        ],
        fallback: [
            {
                name: 'canvas_based',
                method: 'local',
                processor: 'removeBackgroundAdvanced',
                quality: 'fair',
                speed: 'fast',
                enabled: () => true
            }
        ]
    },
    
    // Image generation servisleri
    imageGeneration: {
        primary: [
            {
                name: 'huggingface_sdxl',
                endpoint: 'https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-xl-base-1.0',
                method: 'POST',
                headers: (token) => ({ 'Authorization': `Bearer ${token}` }),
                enabled: () => !!getEnvVariable('HUGGING_FACE_TOKEN'),
                quality: 'excellent',
                speed: 'slow'
            },
            {
                name: 'pollinations',
                endpoint: 'https://image.pollinations.ai/prompt/',
                method: 'GET',
                enabled: () => true,
                quality: 'good',
                speed: 'fast'
            }
        ],
        fallback: [
            {
                name: 'gradient_based',
                method: 'local',
                processor: 'generateBackgroundGradient',
                quality: 'basic',
                speed: 'very_fast',
                enabled: () => true
            }
        ]
    },
    
    // Global ayarlar
    settings: {
        maxRetries: 3,
        timeout: 30000,
        retryDelay: 2000,
        qualityThreshold: 0.7,
        fallbackEnabled: true,
        cacheResults: true,
        compressionQuality: 0.92
    }
};

// Geli≈ümi≈ü API client
class SmartAPIClient {
    constructor(config) {
        this.config = config;
        this.cache = new Map();
        this.metrics = {
            requests: 0,
            successes: 0,
            failures: 0,
            averageResponseTime: 0
        };
    }
    
    async processBackgroundRemoval(imageFile, options = {}) {
        const startTime = Date.now();
        
        try {
            // Cache kontrol√º
            const cacheKey = await this.generateCacheKey(imageFile);
            if (this.config.settings.cacheResults && this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Primary servislerden dene
            for (const service of this.config.backgroundRemoval.primary) {
                if (!service.enabled()) continue;
                
                try {
                    updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan kaldƒ±rƒ±lƒ±yor...`);
                    
                    const result = await this.callService(service, imageFile, options);
                    
                    if (await this.validateResult(result, 'backgroundRemoval')) {
                        this.recordSuccess(Date.now() - startTime);
                        
                        if (this.config.settings.cacheResults) {
                            this.cache.set(cacheKey, result);
                        }
                        
                        return result;
                    }
                    
                } catch (error) {
                    console.error(`${service.name} failed:`, error);
                    this.recordFailure();
                }
            }
            
            // Fallback servisleri dene
            if (this.config.settings.fallbackEnabled) {
                for (const service of this.config.backgroundRemoval.fallback) {
                    if (!service.enabled()) continue;
                    
                    try {
                        updateLoadingMessage(`Yerel i≈üleme ile devam ediliyor...`);
                        const result = await this.callLocalProcessor(service, imageFile, options);
                        
                        if (result) {
                            this.recordSuccess(Date.now() - startTime);
                            return result;
                        }
                        
                    } catch (error) {
                        console.error(`Fallback ${service.name} failed:`, error);
                    }
                }
            }
            
            throw new Error('T√ºm arka plan kaldƒ±rma servisleri ba≈üarƒ±sƒ±z oldu');
            
        } catch (error) {
            this.recordFailure();
            throw error;
        }
    }
    
    async processImageGeneration(prompt, options = {}) {
        const startTime = Date.now();
        
        try {
            // Cache kontrol√º
            const cacheKey = this.hashString(prompt + JSON.stringify(options));
            if (this.config.settings.cacheResults && this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Primary servislerden dene
            for (const service of this.config.imageGeneration.primary) {
                if (!service.enabled()) continue;
                
                try {
                    updateLoadingMessage(`${service.name.toUpperCase()} ile arka plan olu≈üturuluyor...`);
                    
                    const result = await this.callService(service, prompt, options);
                    
                    if (await this.validateResult(result, 'imageGeneration')) {
                        this.recordSuccess(Date.now() - startTime);
                        
                        if (this.config.settings.cacheResults) {
                            this.cache.set(cacheKey, result);
                        }
                        
                        return result;
                    }
                    
                } catch (error) {
                    console.error(`${service.name} failed:`, error);
                    this.recordFailure();
                }
            }
            
            // Fallback servisleri dene
            if (this.config.settings.fallbackEnabled) {
                for (const service of this.config.imageGeneration.fallback) {
                    if (!service.enabled()) continue;
                    
                    try {
                        updateLoadingMessage(`Yerel arka plan olu≈üturuluyor...`);
                        const result = await this.callLocalProcessor(service, prompt, options);
                        
                        if (result) {
                            this.recordSuccess(Date.now() - startTime);
                            return result;
                        }
                        
                    } catch (error) {
                        console.error(`Fallback ${service.name} failed:`, error);
                    }
                }
            }
            
            throw new Error('T√ºm g√∂r√ºnt√º olu≈üturma servisleri ba≈üarƒ±sƒ±z oldu');
            
        } catch (error) {
            this.recordFailure();
            throw error;
        }
    }
    
    async callService(service, data, options) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.config.settings.timeout);
        
        try {
            let response;
            
            if (service.name === 'pollinations') {
                // Pollinations i√ßin √∂zel i≈ülem
                const enhancedPrompt = this.enhancePrompt(data);
                const encodedPrompt = encodeURIComponent(enhancedPrompt);
                const imageUrl = `${service.endpoint}${encodedPrompt}?width=1024&height=1024&seed=${Math.floor(Math.random() * 1000000)}`;
                
                response = await fetch(imageUrl, { signal: controller.signal });
                
            } else if (service.endpoint.startsWith('/functions/')) {
                // Cloudflare functions i√ßin
                const formData = new FormData();
                formData.append('image_file', data);
                if (service.provider) {
                    formData.append('provider', service.provider);
                }
                
                response = await fetch(service.endpoint, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
            } else if (service.method === 'POST') {
                // Standard POST request
                const token = this.getServiceToken(service.name);
                
                if (service.name.includes('huggingface')) {
                    // Hugging Face i√ßin √∂zel format
                    const body = typeof data === 'string' 
                        ? JSON.stringify({ inputs: this.enhancePrompt(data) })
                        : data;
                    
                    response = await fetch(service.endpoint, {
                        method: 'POST',
                        headers: {
                            ...service.headers(token),
                            ...(typeof data === 'string' && { 'Content-Type': 'application/json' })
                        },
                        body: body,
                        signal: controller.signal
                    });
                } else {
                    // Diƒüer servisler i√ßin FormData
                    const formData = new FormData();
                    formData.append('image_file', data);
                    
                    response = await fetch(service.endpoint, {
                        method: 'POST',
                        headers: service.headers(token),
                        body: formData,
                        signal: controller.signal
                    });
                }
            }
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }
            
            // Response type'a g√∂re i≈üle
            if (response.headers.get('content-type')?.includes('application/json')) {
                const json = await response.json();
                
                // Hugging Face error handling
                if (json.error) {
                    throw new Error(`Service error: ${json.error}`);
                }
                
                return json;
            } else {
                const blob = await response.blob();
                return URL.createObjectURL(blob);
            }
            
        } finally {
            clearTimeout(timeoutId);
        }
    }
    
    async callLocalProcessor(service, data, options) {
        switch (service.processor) {
            case 'removeBackgroundAdvanced':
                return await removeBackgroundAdvanced(data);
                
            case 'generateBackgroundGradient':
                return await this.generateBackgroundGradient(data, options);
                
            default:
                throw new Error(`Unknown local processor: ${service.processor}`);
        }
    }
    
    async generateBackgroundGradient(prompt, options) {
        // Lokasyon ve parametrelere g√∂re gradient arka plan olu≈ütur
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1024;
        canvas.height = 1024;
        
        // Prompt'dan renk √ßƒ±kar
        const colors = this.extractColorsFromPrompt(prompt);
        
        // Gradient olu≈ütur
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, colors.primary);
        gradient.addColorStop(0.5, colors.secondary);
        gradient.addColorStop(1, colors.accent);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Texture ekle
        this.addTextureToCanvas(ctx, canvas.width, canvas.height, prompt);
        
        return canvas.toDataURL('image/jpeg', this.config.settings.compressionQuality);
    }
    
    extractColorsFromPrompt(prompt) {
        const colorMap = {
            'paris': { primary: '#87CEEB', secondary: '#F0F8FF', accent: '#FFD700' },
            'tokyo': { primary: '#FF69B4', secondary: '#9370DB', accent: '#00CED1' },
            'newyork': { primary: '#696969', secondary: '#A9A9A9', accent: '#FFD700' },
            'istanbul': { primary: '#4682B4', secondary: '#F0E68C', accent: '#CD853F' },
            'dubai': { primary: '#F4A460', secondary: '#DEB887', accent: '#CD853F' },
            'sunset': { primary: '#FF4500', secondary: '#FFA500', accent: '#FFD700' },
            'morning': { primary: '#87CEEB', secondary: '#E0E6FA', accent: '#FFFAF0' },
            'night': { primary: '#191970', secondary: '#2F2F4F', accent: '#4169E1' },
            'default': { primary: '#87CEEB', secondary: '#F0F8FF', accent: '#FFD700' }
        };
        
        const promptLower = prompt.toLowerCase();
        
        for (const [key, colors] of Object.entries(colorMap)) {
            if (promptLower.includes(key)) {
                return colors;
            }
        }
        
        return colorMap.default;
    }
    
    addTextureToCanvas(ctx, width, height, prompt) {
        // Basit texture pattern ekle
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = '#FFFFFF';
        
        // Prompt'a g√∂re pattern se√ß
        if (prompt.includes('city') || prompt.includes('urban')) {
            // Urban pattern
            for (let x = 0; x < width; x += 50) {
                for (let y = 0; y < height; y += 50) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(x, y, 2, 20);
                        ctx.fillRect(x, y, 20, 2);
                    }
                }
            }
        } else if (prompt.includes('nature') || prompt.includes('landscape')) {
            // Organic pattern
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 10 + 5;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        ctx.globalAlpha = 1.0;
    }
    
    enhancePrompt(prompt) {
        const enhancements = [
            'professional photography',
            'high quality',
            'detailed',
            '8k resolution',
            'cinematic lighting',
            'realistic',
            'sharp focus'
        ];
        
        return `${prompt}, ${enhancements.join(', ')}`;
    }
    
    getServiceToken(serviceName) {
        const tokenMap = {
            'huggingface_rmbg2': 'HUGGING_FACE_TOKEN',
            'huggingface_sdxl': 'HUGGING_FACE_TOKEN',
            'replicate_rmbg': 'REPLICATE_API_TOKEN',
            'removebg': 'REMOVEBG_TOKEN'
        };
        
        return getEnvVariable(tokenMap[serviceName]);
    }
    
    async validateResult(result, type) {
        if (!result) return false;
        
        if (type === 'backgroundRemoval') {
            // URL veya blob kontrol√º
            return typeof result === 'string' && result.startsWith('blob:');
        }
        
        if (type === 'imageGeneration') {
            // URL, blob veya base64 kontrol√º
            return typeof result === 'string' && 
                   (result.startsWith('blob:') || 
                    result.startsWith('data:image/') ||
                    result.startsWith('http'));
        }
        
        return false;
    }
    
    async generateCacheKey(file) {
        // File hash olu≈ütur (basit versiyon)
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-1', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 32-bit integer'a d√∂n√º≈üt√ºr
        }
        return hash.toString();
    }
    
    recordSuccess(responseTime) {
        this.metrics.requests++;
        this.metrics.successes++;
        this.metrics.averageResponseTime = 
            (this.metrics.averageResponseTime * (this.metrics.successes - 1) + responseTime) / 
            this.metrics.successes;
    }
    
    recordFailure() {
        this.metrics.requests++;
        this.metrics.failures++;
    }
    
    getMetrics() {
        return {
            ...this.metrics,
            successRate: this.metrics.requests > 0 ? 
                (this.metrics.successes / this.metrics.requests) * 100 : 0
        };
    }
}

// Global API client instance
const apiClient = new SmartAPIClient(IMPROVED_API_CONFIG);

// G√ºncellenen ana fonksiyonlar
async function removeBackgroundWithRetry(imageFile) {
    return await apiClient.processBackgroundRemoval(imageFile);
}

async function generateBackgroundWithRetry(prompt) {
    return await apiClient.processImageGeneration(prompt);
}

// Progress tracking ile birle≈ütirilmi≈ü ana fonksiyon
async function generatePhotoImproved() {
    if (!selectedPhoto || !selectedLocation) {
        showError('Eksik Bilgi', 'L√ºtfen fotoƒüraf ve lokasyon se√ßin!');
        return;
    }

    closeModal('parametersModal');
    document.getElementById('uploadSection').style.display = 'none';
    hideError();
    
    lastOperation = generatePhotoImproved;
    
    try {
        // Step 1: Image preparation (15%)
        showLoading('üñºÔ∏è Fotoƒüraf Hazƒ±rlanƒ±yor', 'G√∂r√ºnt√º optimize ediliyor...');
        updateProgress(5);
        
        const optimizedImage = await optimizeImageForProcessing(selectedPhoto);
        updateProgress(15);
        
        // Step 2: Advanced background removal (40%)
        updateLoadingTitle('‚úÇÔ∏è Arka Plan Kaldƒ±rƒ±lƒ±yor');
        updateLoadingMessage('AI ile geli≈ümi≈ü arka plan temizleme...');
        updateProgress(20);
        
        const backgroundRemovedImage = await removeBackgroundWithRetry(optimizedImage);
        updateProgress(40);
        
        // Step 3: Enhanced background generation (70%)
        updateLoadingTitle('üé® Yeni Arka Plan Olu≈üturuluyor');
        updateLoadingMessage(`${selectedLocation.name} i√ßin sahne hazƒ±rlanƒ±yor...`);
        updateProgress(45);
        
        const enhancedPrompt = createEnhancedPrompt();
        const newBackground = await generateBackgroundWithRetry(enhancedPrompt);
        updateProgress(70);
        
        // Step 4: Advanced composition (90%)
        updateLoadingTitle('üîÑ Profesyonel Birle≈ütirme');
        updateLoadingMessage('I≈üƒ±k, g√∂lge ve perspektif ayarlanƒ±yor...');
        updateProgress(75);
        
        const finalImage = await combineImagesAdvancedPro(backgroundRemovedImage, newBackground);
        updateProgress(90);
        
        // Step 5: Final optimization (100%)
        updateLoadingMessage('Son dokunu≈ülar ve optimizasyon...');
        const optimizedFinalImage = await applyFinalOptimizations(finalImage);
        updateProgress(100);
        
        setTimeout(() => {
            hideLoading();
            document.getElementById('previewSection').style.display = 'block';
            document.getElementById('previewImage').src = optimizedFinalImage;
            document.getElementById('shareBtn').style.display = 'inline-block';
        }, 500);
        
    } catch (error) {
        console.error('Geli≈ümi≈ü AI i≈üleme hatasƒ±:', error);
        handleProcessingError(error);
    }
}

// Yardƒ±mcƒ± fonksiyonlar
async function optimizeImageForProcessing(imageFile) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve) => {
        img.onload = () => {
            // Optimal boyutlandƒ±rma
            const maxSize = 768; // Y√ºksek kalite i√ßin b√ºy√ºk boyut
            let { width, height } = img;
            
            if (width > height) {
                if (width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                }
            } else {
                if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Y√ºksek kalite rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            ctx.drawImage(img, 0, 0, width, height);
            
            canvas.toBlob(resolve, 'image/jpeg', 0.95);
        };
        
        img.src = URL.createObjectURL(imageFile);
    });
}

function createEnhancedPrompt() {
    const basePrompt = createPrompt(); // Mevcut fonksiyon
    
    // Quality boosters
    const qualityEnhancers = [
        'award winning photography',
        'professional composition',
        'perfect lighting',
        'ultra sharp details',
        'realistic textures',
        'cinematic quality',
        'depth of field',
        'color grading'
    ];
    
    // Negative prompts
    const negativePrompts = [
        'blurry',
        'low quality',
        'pixelated',
        'distorted',
        'artificial',
        'fake',
        'oversaturated'
    ];
    
    return `${basePrompt}, ${qualityEnhancers.join(', ')}, NOT ${negativePrompts.join(', NOT ')}`;
}

async function applyFinalOptimizations(imageDataUrl) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve) => {
        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            
            // Y√ºksek kalite √ßizim
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0);
            
            // Son kalite optimizasyonu
            resolve(canvas.toDataURL('image/jpeg', 0.92));
        };
        
        img.src = imageDataUrl;
    });
}

function handleProcessingError(error) {
    const metrics = apiClient.getMetrics();
    
    let errorTitle = 'ƒ∞≈ülem Hatasƒ±';
    let errorMessage = 'Bir hata olu≈ütu. L√ºtfen tekrar deneyin.';
    
    if (error.message.includes('network')) {
        errorTitle = 'Baƒülantƒ± Hatasƒ±';
        errorMessage = 'ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin ve tekrar deneyin.';
    } else if (error.message.includes('timeout')) {
        errorTitle = 'Zaman A≈üƒ±mƒ±';
        errorMessage = 'ƒ∞≈ülem √ßok uzun s√ºrd√º. Daha k√º√ß√ºk bir fotoƒüraf deneyin.';
    } else if (metrics.successRate < 50) {
        errorTitle = 'Servis Hatasƒ±';
        errorMessage = 'API servisleri ≈üu anda sorunlu. Demo sonu√ß g√∂sterilecek.';
        
        setTimeout(() => {
            hideError();
            showDemoResult();
        }, 2000);
    }
    
    showError(errorTitle, errorMessage, generatePhotoImproved);
}